import { functionOutputKey, } from '@aws-amplify/backend-output-schemas';
import { AttributionMetadataStorage } from '@aws-amplify/backend-output-storage';
import { AmplifyUserError, CallerDirectoryExtractor, TagName, } from '@aws-amplify/platform-core';
import { Duration, Stack, Tags } from 'aws-cdk-lib';
import { Rule } from 'aws-cdk-lib/aws-events';
import * as targets from 'aws-cdk-lib/aws-events-targets';
import { LayerVersion, Runtime, } from 'aws-cdk-lib/aws-lambda';
import { NodejsFunction, OutputFormat } from 'aws-cdk-lib/aws-lambda-nodejs';
import { Construct } from 'constructs';
import { readFileSync } from 'fs';
import { createRequire } from 'module';
import { fileURLToPath } from 'node:url';
import { EOL } from 'os';
import * as path from 'path';
import { FunctionEnvironmentTranslator } from './function_env_translator.js';
import { FunctionEnvironmentTypeGenerator } from './function_env_type_generator.js';
import { FunctionLayerArnParser } from './layer_parser.js';
import { convertFunctionSchedulesToRuleSchedules } from './schedule_parser.js';
import { convertLoggingOptionsToCDK } from './logging_options_parser.js';
const functionStackType = 'function-Lambda';
/**
 * Entry point for defining a function in the Amplify ecosystem
 */
export const defineFunction = (props = {}) => new FunctionFactory(props, new Error().stack);
/**
 * Create Lambda functions in the context of an Amplify backend definition
 */
class FunctionFactory {
    props;
    callerStack;
    generator;
    /**
     * Create a new AmplifyFunctionFactory
     */
    constructor(props, callerStack) {
        this.props = props;
        this.callerStack = callerStack;
    }
    /**
     * Creates an instance of AmplifyFunction within the provided Amplify context
     */
    getInstance = ({ constructContainer, outputStorageStrategy, resourceNameValidator, }) => {
        if (!this.generator) {
            this.generator = new FunctionGenerator(this.hydrateDefaults(resourceNameValidator), outputStorageStrategy);
        }
        return constructContainer.getOrCompute(this.generator);
    };
    hydrateDefaults = (resourceNameValidator) => {
        const name = this.resolveName();
        resourceNameValidator?.validate(name);
        const parser = new FunctionLayerArnParser();
        const layers = parser.parseLayers(this.props.layers ?? {}, name);
        return {
            name,
            entry: this.resolveEntry(),
            timeoutSeconds: this.resolveTimeout(),
            memoryMB: this.resolveMemory(),
            environment: this.resolveEnvironment(),
            runtime: this.resolveRuntime(),
            schedule: this.resolveSchedule(),
            bundling: this.resolveBundling(),
            layers,
            resourceGroupName: this.props.resourceGroupName ?? 'function',
            logging: this.props.logging ?? {},
        };
    };
    resolveName = () => {
        // If name is set explicitly, use that
        if (this.props.name) {
            return this.props.name;
        }
        // If entry is set, use the basename of the entry path
        if (this.props.entry) {
            return path.parse(this.props.entry).name;
        }
        // Otherwise, use the directory name where the function is defined
        return path.basename(new CallerDirectoryExtractor(this.callerStack).extract());
    };
    resolveEntry = () => {
        // if entry is not set, default to handler.ts
        if (!this.props.entry) {
            return path.join(new CallerDirectoryExtractor(this.callerStack).extract(), 'handler.ts');
        }
        // if entry is absolute use that
        if (path.isAbsolute(this.props.entry)) {
            return this.props.entry;
        }
        // if entry is relative, compute with respect to the caller directory
        return path.join(new CallerDirectoryExtractor(this.callerStack).extract(), this.props.entry);
    };
    resolveTimeout = () => {
        const timeoutMin = 1;
        const timeoutMax = 60 * 15; // 15 minutes in seconds
        const timeoutDefault = 3;
        if (this.props.timeoutSeconds === undefined) {
            return timeoutDefault;
        }
        if (!isWholeNumberBetweenInclusive(this.props.timeoutSeconds, timeoutMin, timeoutMax)) {
            throw new AmplifyUserError('InvalidTimeoutError', {
                message: `Invalid function timeout of ${this.props.timeoutSeconds}`,
                resolution: `timeoutSeconds must be a whole number between ${timeoutMin} and ${timeoutMax} inclusive`,
            });
        }
        return this.props.timeoutSeconds;
    };
    resolveMemory = () => {
        const memoryMin = 128;
        const memoryMax = 10240;
        const memoryDefault = 512;
        if (this.props.memoryMB === undefined) {
            return memoryDefault;
        }
        if (!isWholeNumberBetweenInclusive(this.props.memoryMB, memoryMin, memoryMax)) {
            throw new AmplifyUserError('InvalidMemoryMBError', {
                message: `Invalid function memoryMB of ${this.props.memoryMB}`,
                resolution: `memoryMB must be a whole number between ${memoryMin} and ${memoryMax} inclusive`,
            });
        }
        return this.props.memoryMB;
    };
    resolveEnvironment = () => {
        if (this.props.environment === undefined) {
            return {};
        }
        const invalidKeys = [];
        Object.keys(this.props.environment).forEach((key) => {
            // validate using key pattern from https://docs.aws.amazon.com/lambda/latest/api/API_Environment.html
            if (!key.match(/^[a-zA-Z]([a-zA-Z0-9_])+$/)) {
                invalidKeys.push(key);
            }
        });
        if (invalidKeys.length > 0) {
            throw new AmplifyUserError('InvalidEnvironmentKeyError', {
                message: `Invalid function environment key(s): ${invalidKeys.join(', ')}`,
                resolution: 'Environment keys must match [a-zA-Z]([a-zA-Z0-9_])+ and be at least 2 characters',
            });
        }
        return this.props.environment;
    };
    resolveRuntime = () => {
        const runtimeDefault = 18;
        // if runtime is not set, default to the oldest LTS
        if (!this.props.runtime) {
            return runtimeDefault;
        }
        if (!(this.props.runtime in nodeVersionMap)) {
            throw new AmplifyUserError('InvalidRuntimeError', {
                message: `Invalid function runtime of ${this.props.runtime}`,
                resolution: `runtime must be one of the following: ${Object.keys(nodeVersionMap).join(', ')}`,
            });
        }
        return this.props.runtime;
    };
    resolveSchedule = () => {
        if (!this.props.schedule) {
            return [];
        }
        return this.props.schedule;
    };
    resolveBundling = () => {
        const bundlingDefault = {
            format: OutputFormat.ESM,
            bundleAwsSDK: true,
            loader: {
                '.node': 'file',
            },
            minify: true,
            sourceMap: true,
        };
        return {
            ...bundlingDefault,
            minify: this.resolveMinify(this.props.bundling),
        };
    };
    resolveMinify = (bundling) => {
        return bundling?.minify === undefined ? true : bundling.minify;
    };
}
class FunctionGenerator {
    props;
    outputStorageStrategy;
    resourceGroupName;
    constructor(props, outputStorageStrategy) {
        this.props = props;
        this.outputStorageStrategy = outputStorageStrategy;
        this.resourceGroupName = props.resourceGroupName;
    }
    generateContainerEntry = ({ scope, backendSecretResolver, }) => {
        // resolve layers to LayerVersion objects for the NodejsFunction constructor using the scope.
        const resolvedLayers = Object.entries(this.props.layers).map(([key, arn]) => LayerVersion.fromLayerVersionArn(scope, `${this.props.name}-${key}-layer`, arn));
        return new AmplifyFunction(scope, this.props.name, { ...this.props, resolvedLayers }, backendSecretResolver, this.outputStorageStrategy);
    };
}
class AmplifyFunction extends Construct {
    resources;
    stack;
    functionEnvironmentTranslator;
    constructor(scope, id, props, backendSecretResolver, outputStorageStrategy) {
        super(scope, id);
        this.stack = Stack.of(scope);
        const runtime = nodeVersionMap[props.runtime];
        const require = createRequire(import.meta.url);
        const shims = runtime === Runtime.NODEJS_16_X
            ? []
            : [require.resolve('./lambda-shims/cjs_shim')];
        const ssmResolverFile = runtime === Runtime.NODEJS_16_X
            ? require.resolve('./lambda-shims/resolve_ssm_params_sdk_v2') // use aws cdk v2 in node 16
            : require.resolve('./lambda-shims/resolve_ssm_params');
        const invokeSsmResolverFile = require.resolve('./lambda-shims/invoke_ssm_shim');
        /**
         * This code concatenates the contents of the ssm resolver and invoker into a single line that can be used as the esbuild banner content
         * This banner is responsible for resolving the customer's SSM parameters at runtime
         */
        const bannerCode = readFileSync(ssmResolverFile, 'utf-8')
            .concat(readFileSync(invokeSsmResolverFile, 'utf-8'))
            .split(new RegExp(`${EOL}|\n|\r`, 'g'))
            .map((line) => line.replace(/\/\/.*$/, '')) // strip out inline comments because the banner is going to be flattened into a single line
            .join('');
        const functionEnvironmentTypeGenerator = new FunctionEnvironmentTypeGenerator(id);
        // esbuild runs as part of the NodejsFunction constructor, so we eagerly generate the process env shim without types so it can be included in the function bundle.
        // This will be overwritten with the typed file at the end of synthesis
        functionEnvironmentTypeGenerator.generateProcessEnvShim();
        let functionLambda;
        const cdkLoggingOptions = convertLoggingOptionsToCDK(props.logging);
        try {
            functionLambda = new NodejsFunction(scope, `${id}-lambda`, {
                entry: props.entry,
                timeout: Duration.seconds(props.timeoutSeconds),
                memorySize: props.memoryMB,
                runtime: nodeVersionMap[props.runtime],
                layers: props.resolvedLayers,
                bundling: {
                    ...props.bundling,
                    banner: bannerCode,
                    inject: shims,
                    externalModules: Object.keys(props.layers),
                },
                logRetention: cdkLoggingOptions.retention,
                applicationLogLevelV2: cdkLoggingOptions.level,
                loggingFormat: cdkLoggingOptions.format,
            });
        }
        catch (error) {
            // If the error is from ES Bundler which is executed as a child process by CDK,
            // then the error from CDK contains the command that was executed along with the exit status.
            // Wrapping it here  would cause the cdk_deployer to re-throw this wrapped exception
            // instead of scraping the stderr for actual ESBuild error.
            if (error instanceof Error &&
                error.message.match(/Failed to bundle asset.*exited with status/)) {
                throw error;
            }
            throw new AmplifyUserError('NodeJSFunctionConstructInitializationError', {
                message: 'Failed to instantiate nodejs function construct',
                resolution: 'See the underlying error message for more details. Use `--debug` for additional debugging information.',
            }, error);
        }
        try {
            const schedules = convertFunctionSchedulesToRuleSchedules(functionLambda, props.schedule);
            const lambdaTarget = new targets.LambdaFunction(functionLambda);
            schedules.forEach((schedule, index) => {
                // Lambda name will be prepended to rule id, so only using index here for uniqueness
                const rule = new Rule(functionLambda, `schedule${index}`, {
                    schedule,
                });
                rule.addTarget(lambdaTarget);
            });
        }
        catch (error) {
            throw new AmplifyUserError('FunctionScheduleInitializationError', {
                message: 'Failed to instantiate schedule for nodejs function',
                resolution: 'See the underlying error message for more details.',
            }, error);
        }
        Tags.of(functionLambda).add(TagName.FRIENDLY_NAME, id);
        this.functionEnvironmentTranslator = new FunctionEnvironmentTranslator(functionLambda, props.environment, backendSecretResolver, functionEnvironmentTypeGenerator);
        this.resources = {
            lambda: functionLambda,
            cfnResources: {
                cfnFunction: functionLambda.node.findChild('Resource'),
            },
        };
        this.storeOutput(outputStorageStrategy);
        new AttributionMetadataStorage().storeAttributionMetadata(Stack.of(this), functionStackType, fileURLToPath(new URL('../package.json', import.meta.url)));
    }
    addEnvironment = (key, value) => {
        this.functionEnvironmentTranslator.addEnvironmentEntry(key, value);
    };
    getResourceAccessAcceptor = () => ({
        identifier: `${this.node.id}LambdaResourceAccessAcceptor`,
        acceptResourceAccess: (policy, ssmEnvironmentEntries) => {
            const role = this.resources.lambda.role;
            if (!role) {
                // This should never happen since we are using the Function L2 construct
                throw new Error('No execution role found to attach lambda permissions to');
            }
            policy.attachToRole(role);
            ssmEnvironmentEntries.forEach(({ name, path }) => {
                this.functionEnvironmentTranslator.addSsmEnvironmentEntry(name, path);
            });
        },
    });
    /**
     * Store storage outputs using provided strategy
     */
    storeOutput = (outputStorageStrategy) => {
        outputStorageStrategy.appendToBackendOutputList(functionOutputKey, {
            version: '1',
            payload: {
                definedFunctions: this.resources.lambda.functionName,
            },
        });
    };
}
const isWholeNumberBetweenInclusive = (test, min, max) => min <= test && test <= max && test % 1 === 0;
const nodeVersionMap = {
    16: Runtime.NODEJS_16_X,
    18: Runtime.NODEJS_18_X,
    20: Runtime.NODEJS_20_X,
    22: Runtime.NODEJS_22_X,
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmFjdG9yeS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9mYWN0b3J5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFFTCxpQkFBaUIsR0FDbEIsTUFBTSxxQ0FBcUMsQ0FBQztBQUM3QyxPQUFPLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSxxQ0FBcUMsQ0FBQztBQUNqRixPQUFPLEVBQ0wsZ0JBQWdCLEVBQ2hCLHdCQUF3QixFQUN4QixPQUFPLEdBQ1IsTUFBTSw0QkFBNEIsQ0FBQztBQW1CcEMsT0FBTyxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBQ3BELE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUM5QyxPQUFPLEtBQUssT0FBTyxNQUFNLGdDQUFnQyxDQUFDO0FBRTFELE9BQU8sRUFHTCxZQUFZLEVBQ1osT0FBTyxHQUNSLE1BQU0sd0JBQXdCLENBQUM7QUFDaEMsT0FBTyxFQUFFLGNBQWMsRUFBRSxZQUFZLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQztBQUM3RSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sWUFBWSxDQUFDO0FBQ3ZDLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxJQUFJLENBQUM7QUFDbEMsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLFFBQVEsQ0FBQztBQUN2QyxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sVUFBVSxDQUFDO0FBQ3pDLE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxJQUFJLENBQUM7QUFDekIsT0FBTyxLQUFLLElBQUksTUFBTSxNQUFNLENBQUM7QUFDN0IsT0FBTyxFQUFFLDZCQUE2QixFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFDN0UsT0FBTyxFQUFFLGdDQUFnQyxFQUFFLE1BQU0sa0NBQWtDLENBQUM7QUFDcEYsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDM0QsT0FBTyxF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ImltcG9ydCB7XG4gIEZ1bmN0aW9uT3V0cHV0LFxuICBmdW5jdGlvbk91dHB1dEtleSxcbn0gZnJvbSAnQGF3cy1hbXBsaWZ5L2JhY2tlbmQtb3V0cHV0LXNjaGVtYXMnO1xuaW1wb3J0IHsgQXR0cmlidXRpb25NZXRhZGF0YVN0b3JhZ2UgfSBmcm9tICdAYXdzLWFtcGxpZnkvYmFja2VuZC1vdXRwdXQtc3RvcmFnZSc7XG5pbXBvcnQge1xuICBBbXBsaWZ5VXNlckVycm9yLFxuICBDYWxsZXJEaXJlY3RvcnlFeHRyYWN0b3IsXG4gIFRhZ05hbWUsXG59IGZyb20gJ0Bhd3MtYW1wbGlmeS9wbGF0Zm9ybS1jb3JlJztcbmltcG9ydCB7XG4gIEFtcGxpZnlSZXNvdXJjZUdyb3VwTmFtZSxcbiAgQmFja2VuZE91dHB1dFN0b3JhZ2VTdHJhdGVneSxcbiAgQmFja2VuZFNlY3JldCxcbiAgQmFja2VuZFNlY3JldFJlc29sdmVyLFxuICBDb25zdHJ1Y3RDb250YWluZXJFbnRyeUdlbmVyYXRvcixcbiAgQ29uc3RydWN0RmFjdG9yeSxcbiAgQ29uc3RydWN0RmFjdG9yeUdldEluc3RhbmNlUHJvcHMsXG4gIEZ1bmN0aW9uUmVzb3VyY2VzLFxuICBHZW5lcmF0ZUNvbnRhaW5lckVudHJ5UHJvcHMsXG4gIExvZ0xldmVsLFxuICBMb2dSZXRlbnRpb24sXG4gIFJlc291cmNlQWNjZXNzQWNjZXB0b3JGYWN0b3J5LFxuICBSZXNvdXJjZU5hbWVWYWxpZGF0b3IsXG4gIFJlc291cmNlUHJvdmlkZXIsXG4gIFNzbUVudmlyb25tZW50RW50cnksXG4gIFN0YWNrUHJvdmlkZXIsXG59IGZyb20gJ0Bhd3MtYW1wbGlmeS9wbHVnaW4tdHlwZXMnO1xuaW1wb3J0IHsgRHVyYXRpb24sIFN0YWNrLCBUYWdzIH0gZnJvbSAnYXdzLWNkay1saWInO1xuaW1wb3J0IHsgUnVsZSB9IGZyb20gJ2F3cy1jZGstbGliL2F3cy1ldmVudHMnO1xuaW1wb3J0ICogYXMgdGFyZ2V0cyBmcm9tICdhd3MtY2RrLWxpYi9hd3MtZXZlbnRzLXRhcmdldHMnO1xuaW1wb3J0IHsgUG9saWN5IH0gZnJvbSAnYXdzLWNkay1saWIvYXdzLWlhbSc7XG5pbXBvcnQge1xuICBDZm5GdW5jdGlvbixcbiAgSUxheWVyVmVyc2lvbixcbiAgTGF5ZXJWZXJzaW9uLFxuICBSdW50aW1lLFxufSBmcm9tICdhd3MtY2RrLWxpYi9hd3MtbGFtYmRhJztcbmltcG9ydCB7IE5vZGVqc0Z1bmN0aW9uLCBPdXRwdXRGb3JtYXQgfSBmcm9tICdhd3MtY2RrLWxpYi9hd3MtbGFtYmRhLW5vZGVqcyc7XG5pbXBvcnQgeyBDb25zdHJ1Y3QgfSBmcm9tICdjb25zdHJ1Y3RzJztcbmltcG9ydCB7IHJlYWRGaWxlU3luYyB9IGZyb20gJ2ZzJztcbmltcG9ydCB7IGNyZWF0ZVJlcXVpcmUgfSBmcm9tICdtb2R1bGUnO1xuaW1wb3J0IHsgZmlsZVVSTFRvUGF0aCB9IGZyb20gJ25vZGU6dXJsJztcbmltcG9ydCB7IEVPTCB9IGZyb20gJ29zJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBGdW5jdGlvbkVudmlyb25tZW50VHJhbnNsYXRvciB9IGZyb20gJy4vZnVuY3Rpb25fZW52X3RyYW5zbGF0b3IuanMnO1xuaW1wb3J0IHsgRnVuY3Rpb25FbnZpcm9ubWVudFR5cGVHZW5lcmF0b3IgfSBmcm9tICcuL2Z1bmN0aW9uX2Vudl90eXBlX2dlbmVyYXRvci5qcyc7XG5pbXBvcnQgeyBGdW5jdGlvbkxheWVyQXJuUGFyc2VyIH0gZnJvbSAnLi9sYXllcl9wYXJzZXIuanMnO1xuaW1wb3J0IHsgY29udmVydEZ1bmN0aW9uU2NoZWR1bGVzVG9SdWxlU2NoZWR1bGVzIH0gZnJvbSAnLi9zY2hlZHVsZV9wYXJzZXIuanMnO1xuaW1wb3J0IHsgY29udmVydExvZ2dpbmdPcHRpb25zVG9DREsgfSBmcm9tICcuL2xvZ2dpbmdfb3B0aW9uc19wYXJzZXIuanMnO1xuXG5jb25zdCBmdW5jdGlvblN0YWNrVHlwZSA9ICdmdW5jdGlvbi1MYW1iZGEnO1xuXG5leHBvcnQgdHlwZSBBZGRFbnZpcm9ubWVudEZhY3RvcnkgPSB7XG4gIGFkZEVudmlyb25tZW50OiAoa2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgfCBCYWNrZW5kU2VjcmV0KSA9PiB2b2lkO1xufTtcblxuZXhwb3J0IHR5cGUgQ3JvblNjaGVkdWxlID1cbiAgfCBgJHtzdHJpbmd9ICR7c3RyaW5nfSAke3N0cmluZ30gJHtzdHJpbmd9ICR7c3RyaW5nfWBcbiAgfCBgJHtzdHJpbmd9ICR7c3RyaW5nfSAke3N0cmluZ30gJHtzdHJpbmd9ICR7c3RyaW5nfSAke3N0cmluZ31gO1xuZXhwb3J0IHR5cGUgVGltZUludGVydmFsID1cbiAgfCBgZXZlcnkgJHtudW1iZXJ9bWBcbiAgfCBgZXZlcnkgJHtudW1iZXJ9aGBcbiAgfCBgZXZlcnkgZGF5YFxuICB8IGBldmVyeSB3ZWVrYFxuICB8IGBldmVyeSBtb250aGBcbiAgfCBgZXZlcnkgeWVhcmA7XG5leHBvcnQgdHlwZSBGdW5jdGlvblNjaGVkdWxlID0gVGltZUludGVydmFsIHwgQ3JvblNjaGVkdWxlO1xuXG5leHBvcnQgdHlwZSBGdW5jdGlvbkxvZ0xldmVsID0gTG9nTGV2ZWw7XG5leHBvcnQgdHlwZSBGdW5jdGlvbkxvZ1JldGVudGlvbiA9IExvZ1JldGVudGlvbjtcblxuLyoqXG4gKiBFbnRyeSBwb2ludCBmb3IgZGVmaW5pbmcgYSBmdW5jdGlvbiBpbiB0aGUgQW1wbGlmeSBlY29zeXN0ZW1cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmluZUZ1bmN0aW9uID0gKFxuICBwcm9wczogRnVuY3Rpb25Qcm9wcyA9IHt9XG4pOiBDb25zdHJ1Y3RGYWN0b3J5PFxuICBSZXNvdXJjZVByb3ZpZGVyPEZ1bmN0aW9uUmVzb3VyY2VzPiAmXG4gICAgUmVzb3VyY2VBY2Nlc3NBY2NlcHRvckZhY3RvcnkgJlxuICAgIEFkZEVudmlyb25tZW50RmFjdG9yeSAmXG4gICAgU3RhY2tQcm92aWRlclxuPiA9PiBuZXcgRnVuY3Rpb25GYWN0b3J5KHByb3BzLCBuZXcgRXJyb3IoKS5zdGFjayk7XG5cbmV4cG9ydCB0eXBlIEZ1bmN0aW9uUHJvcHMgPSB7XG4gIC8qKlxuICAgKiBBIG5hbWUgZm9yIHRoZSBmdW5jdGlvbi5cbiAgICogRGVmYXVsdHMgdG8gdGhlIGJhc2VuYW1lIG9mIHRoZSBlbnRyeSBwYXRoIGlmIHNwZWNpZmllZC5cbiAgICogSWYgbm8gZW50cnkgaXMgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byB0aGUgZGlyZWN0b3J5IG5hbWUgaW4gd2hpY2ggdGhpcyBmdW5jdGlvbiBpcyBkZWZpbmVkLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKiBJZiBlbnRyeSBpcyBgLi9zY2hlZHVsZWQtZGItYmFja3VwLnRzYCB0aGUgbmFtZSB3aWxsIGRlZmF1bHQgdG8gXCJzY2hlZHVsZWQtZGItYmFja3VwXCJcbiAgICogSWYgZW50cnkgaXMgbm90IHNldCBhbmQgdGhlIGZ1bmN0aW9uIGlzIGRlZmluZWQgaW4gYGFtcGxpZnkvZnVuY3Rpb25zL2RiLWJhY2t1cC9yZXNvdXJjZS50c2AgdGhlIG5hbWUgd2lsbCBkZWZhdWx0IHRvIFwiZGItYmFja3VwXCJcbiAgICovXG4gIG5hbWU/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgcGF0aCB0byB0aGUgZmlsZSB0aGF0IGNvbnRhaW5zIHRoZSBmdW5jdGlvbiBlbnRyeSBwb2ludC5cbiAgICogSWYgdGhpcyBpcyBhIHJlbGF0aXZlIHBhdGgsIGl0IGlzIGNvbXB1dGVkIHJlbGF0aXZlIHRvIHRoZSBmaWxlIHdoZXJlIHRoaXMgZnVuY3Rpb24gaXMgZGVmaW5lZFxuICAgKlxuICAgKiBEZWZhdWx0cyB0byAnLi9oYW5kbGVyLnRzJ1xuICAgKi9cbiAgZW50cnk/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFuIGFtb3VudCBvZiB0aW1lIGluIHNlY29uZHMgYmV0d2VlbiAxIHNlY29uZCBhbmQgMTUgbWludXRlcy5cbiAgICogTXVzdCBiZSBhIHdob2xlIG51bWJlci5cbiAgICogRGVmYXVsdCBpcyAzIHNlY29uZHMuXG4gICAqL1xuICB0aW1lb3V0U2Vjb25kcz86IG51bWJlcjtcblxuICAvKipcbiAgICogQW4gYW1vdW50IG9mIG1lbW9yeSAoUkFNKSB0byBhbGxvY2F0ZSB0byB0aGUgZnVuY3Rpb24gYmV0d2VlbiAxMjggYW5kIDEwMjQwIE1CLlxuICAgKiBNdXN0IGJlIGEgd2hvbGUgbnVtYmVyLlxuICAgKiBEZWZhdWx0IGlzIDUxMk1CLlxuICAgKi9cbiAgbWVtb3J5TUI/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEVudmlyb25tZW50IHZhcmlhYmxlcyB0aGF0IHdpbGwgYmUgYXZhaWxhYmxlIGR1cmluZyBmdW5jdGlvbiBleGVjdXRpb25cbiAgICovXG4gIGVudmlyb25tZW50PzogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgQmFja2VuZFNlY3JldD47XG5cbiAgLyoqXG4gICAqIE5vZGUgcnVudGltZSB2ZXJzaW9uIGZvciB0aGUgbGFtYmRhIGVudmlyb25tZW50LlxuICAgKlxuICAgKiBEZWZhdWx0cyB0byB0aGUgb2xkZXN0IE5vZGVKUyBMVFMgdmVyc2lvbi4gU2VlIGh0dHBzOi8vbm9kZWpzLm9yZy9lbi9hYm91dC9wcmV2aW91cy1yZWxlYXNlc1xuICAgKi9cbiAgcnVudGltZT86IE5vZGVWZXJzaW9uO1xuXG4gIC8qKlxuICAgKiBBIHRpbWUgaW50ZXJ2YWwgc3RyaW5nIHRvIHBlcmlvZGljYWxseSBydW4gdGhlIGZ1bmN0aW9uLlxuICAgKiBUaGlzIGNhbiBiZSBlaXRoZXIgYSBzdHJpbmcgb2YgYFwiZXZlcnkgPHBvc2l0aXZlIHdob2xlIG51bWJlcj48bSAobWludXRlKSBvciBoIChob3VyKT5cImAsIGBcImV2ZXJ5IGRheXx3ZWVrfG1vbnRofHllYXJcImAgb3IgY3JvbiBleHByZXNzaW9uLlxuICAgKiBEZWZhdWx0cyB0byBubyBzY2hlZHVsaW5nIGZvciB0aGUgZnVuY3Rpb24uXG4gICAqIEBleGFtcGxlXG4gICAqIHNjaGVkdWxlOiBcImV2ZXJ5IDVtXCJcbiAgICogQGV4YW1wbGVcbiAgICogc2NoZWR1bGU6IFwiZXZlcnkgd2Vla1wiXG4gICAqIEBleGFtcGxlXG4gICAqIHNjaGVkdWxlOiBcIjAgOSA/ICogMiAqXCIgLy8gZXZlcnkgTW9uZGF5IGF0IDlhbVxuICAgKi9cbiAgc2NoZWR1bGU/OiBGdW5jdGlvblNjaGVkdWxlIHwgRnVuY3Rpb25TY2hlZHVsZVtdO1xuXG4gIC8qKlxuICAgKiBBdHRhY2ggTGFtYmRhIGxheWVycyB0byBhIGZ1bmN0aW9uXG4gICAqIC0gQSBMYW1iZGEgbGF5ZXIgaXMgcmVwcmVzZW50ZWQgYnkgYW4gb2JqZWN0IG9mIGtleS92YWx1ZSBwYWlyIHdoZXJlIHRoZSBrZXkgaXMgdGhlIG1vZHVsZSBuYW1lIHRoYXQgaXMgZXhwb3J0ZWQgZnJvbSB5b3VyIGxheWVyIGFuZCB0aGUgdmFsdWUgaXMgdGhlIEFSTiBvZiB0aGUgbGF5ZXIuIFRoZSBrZXkgKG1vZHVsZSBuYW1lKSBpcyB1c2VkIHRvIGV4dGVybmFsaXplIHRoZSBtb2R1bGUgZGVwZW5kZW5jeSBzbyBpdCBkb2Vzbid0IGdldCBidW5kbGVkIHdpdGggeW91ciBsYW1iZGEgZnVuY3Rpb25cbiAgICogLSBNYXhpbXVtIG9mIDUgbGF5ZXJzIGNhbiBiZSBhdHRhY2hlZCB0byBhIGZ1bmN0aW9uIGFuZCBtdXN0IGJlIGluIHRoZSBzYW1lIHJlZ2lvbiBhcyB0aGUgZnVuY3Rpb24uXG4gICAqIEBleGFtcGxlXG4gICAqIGxheWVyczoge1xuICAgKiAgICBcIkBhd3MtbGFtYmRhLXBvd2VydG9vbHMvbG9nZ2VyXCI6IFwiYXJuOmF3czpsYW1iZGE6PGN1cnJlbnQtcmVnaW9uPjowOTQyNzQxMDU5MTU6bGF5ZXI6QVdTTGFtYmRhUG93ZXJ0b29sc1R5cGVTY3JpcHRWMjoxMVwiXG4gICAqIH0sXG4gICAqIEBzZWUgW0FtcGxpZnkgZG9jdW1lbnRhdGlvbiBmb3IgTGFtYmRhIGxheWVyc10oaHR0cHM6Ly9kb2NzLmFtcGxpZnkuYXdzL3JlYWN0L2J1aWxkLWEtYmFja2VuZC9mdW5jdGlvbnMvYWRkLWxhbWJkYS1sYXllcnMpXG4gICAqIEBzZWUgW0FXUyBkb2N1bWVudGF0aW9uIGZvciBMYW1iZGEgbGF5ZXJzXShodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vbGFtYmRhL2xhdGVzdC9kZy9jaGFwdGVyLWxheWVycy5odG1sKVxuICAgKi9cbiAgbGF5ZXJzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcblxuICAvKlxuICAgKiBPcHRpb25zIGZvciBidW5kbGluZyB0aGUgZnVuY3Rpb24gY29kZS5cbiAgICovXG4gIGJ1bmRsaW5nPzogRnVuY3Rpb25CdW5kbGluZ09wdGlvbnM7XG5cbiAgLyoqXG4gICAqIEdyb3VwIHRoZSBmdW5jdGlvbiB3aXRoIGV4aXN0aW5nIEFtcGxpZnkgcmVzb3VyY2VzIG9yIHNlcGFyYXRlIHRoZSBmdW5jdGlvbiBpbnRvIGl0cyBvd24gZ3JvdXAuXG4gICAqIEBkZWZhdWx0ICdmdW5jdGlvbicgLy8gZ3JvdXBpbmcgd2l0aCBvdGhlciBBbXBsaWZ5IGZ1bmN0aW9uc1xuICAgKiBAZXhhbXBsZVxuICAgKiByZXNvdXJjZUdyb3VwTmFtZTogJ2F1dGgnIC8vIHRvIGdyb3VwIGFuIGF1dGggdHJpZ2dlciB3aXRoIGFuIGF1dGggcmVzb3VyY2VcbiAgICovXG4gIHJlc291cmNlR3JvdXBOYW1lPzogQW1wbGlmeVJlc291cmNlR3JvdXBOYW1lO1xuXG4gIGxvZ2dpbmc/OiBGdW5jdGlvbkxvZ2dpbmdPcHRpb25zO1xufTtcblxuZXhwb3J0IHR5cGUgRnVuY3Rpb25CdW5kbGluZ09wdGlvbnMgPSB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIG1pbmlmeSB0aGUgZnVuY3Rpb24gY29kZS5cbiAgICpcbiAgICogRGVmYXVsdHMgdG8gdHJ1ZS5cbiAgICovXG4gIG1pbmlmeT86IGJvb2xlYW47XG59O1xuXG5leHBvcnQgdHlwZSBGdW5jdGlvbkxvZ2dpbmdPcHRpb25zID0gKFxuICB8IHtcbiAgICAgIGZvcm1hdDogJ2pzb24nO1xuICAgICAgbGV2ZWw/OiBGdW5jdGlvbkxvZ0xldmVsO1xuICAgIH1cbiAgfCB7XG4gICAgICBmb3JtYXQ/OiAndGV4dCc7XG4gICAgfVxuKSAmIHtcbiAgcmV0ZW50aW9uPzogRnVuY3Rpb25Mb2dSZXRlbnRpb247XG59O1xuXG4vKipcbiAqIENyZWF0ZSBMYW1iZGEgZnVuY3Rpb25zIGluIHRoZSBjb250ZXh0IG9mIGFuIEFtcGxpZnkgYmFja2VuZCBkZWZpbml0aW9uXG4gKi9cbmNsYXNzIEZ1bmN0aW9uRmFjdG9yeSBpbXBsZW1lbnRzIENvbnN0cnVjdEZhY3Rvcnk8QW1wbGlmeUZ1bmN0aW9uPiB7XG4gIHByaXZhdGUgZ2VuZXJhdG9yOiBDb25zdHJ1Y3RDb250YWluZXJFbnRyeUdlbmVyYXRvcjtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBBbXBsaWZ5RnVuY3Rpb25GYWN0b3J5XG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IHByb3BzOiBGdW5jdGlvblByb3BzLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY2FsbGVyU3RhY2s/OiBzdHJpbmdcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEFtcGxpZnlGdW5jdGlvbiB3aXRoaW4gdGhlIHByb3ZpZGVkIEFtcGxpZnkgY29udGV4dFxuICAgKi9cbiAgZ2V0SW5zdGFuY2UgPSAoe1xuICAgIGNvbnN0cnVjdENvbnRhaW5lcixcbiAgICBvdXRwdXRTdG9yYWdlU3RyYXRlZ3ksXG4gICAgcmVzb3VyY2VOYW1lVmFsaWRhdG9yLFxuICB9OiBDb25zdHJ1Y3RGYWN0b3J5R2V0SW5zdGFuY2VQcm9wcyk6IEFtcGxpZnlGdW5jdGlvbiA9PiB7XG4gICAgaWYgKCF0aGlzLmdlbmVyYXRvcikge1xuICAgICAgdGhpcy5nZW5lcmF0b3IgPSBuZXcgRnVuY3Rpb25HZW5lcmF0b3IoXG4gICAgICAgIHRoaXMuaHlkcmF0ZURlZmF1bHRzKHJlc291cmNlTmFtZVZhbGlkYXRvciksXG4gICAgICAgIG91dHB1dFN0b3JhZ2VTdHJhdGVneVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnN0cnVjdENvbnRhaW5lci5nZXRPckNvbXB1dGUodGhpcy5nZW5lcmF0b3IpIGFzIEFtcGxpZnlGdW5jdGlvbjtcbiAgfTtcblxuICBwcml2YXRlIGh5ZHJhdGVEZWZhdWx0cyA9IChcbiAgICByZXNvdXJjZU5hbWVWYWxpZGF0b3I/OiBSZXNvdXJjZU5hbWVWYWxpZGF0b3JcbiAgKTogSHlkcmF0ZWRGdW5jdGlvblByb3BzID0+IHtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5yZXNvbHZlTmFtZSgpO1xuICAgIHJlc291cmNlTmFtZVZhbGlkYXRvcj8udmFsaWRhdGUobmFtZSk7XG4gICAgY29uc3QgcGFyc2VyID0gbmV3IEZ1bmN0aW9uTGF5ZXJBcm5QYXJzZXIoKTtcbiAgICBjb25zdCBsYXllcnMgPSBwYXJzZXIucGFyc2VMYXllcnModGhpcy5wcm9wcy5sYXllcnMgPz8ge30sIG5hbWUpO1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lLFxuICAgICAgZW50cnk6IHRoaXMucmVzb2x2ZUVudHJ5KCksXG4gICAgICB0aW1lb3V0U2Vjb25kczogdGhpcy5yZXNvbHZlVGltZW91dCgpLFxuICAgICAgbWVtb3J5TUI6IHRoaXMucmVzb2x2ZU1lbW9yeSgpLFxuICAgICAgZW52aXJvbm1lbnQ6IHRoaXMucmVzb2x2ZUVudmlyb25tZW50KCksXG4gICAgICBydW50aW1lOiB0aGlzLnJlc29sdmVSdW50aW1lKCksXG4gICAgICBzY2hlZHVsZTogdGhpcy5yZXNvbHZlU2NoZWR1bGUoKSxcbiAgICAgIGJ1bmRsaW5nOiB0aGlzLnJlc29sdmVCdW5kbGluZygpLFxuICAgICAgbGF5ZXJzLFxuICAgICAgcmVzb3VyY2VHcm91cE5hbWU6IHRoaXMucHJvcHMucmVzb3VyY2VHcm91cE5hbWUgPz8gJ2Z1bmN0aW9uJyxcbiAgICAgIGxvZ2dpbmc6IHRoaXMucHJvcHMubG9nZ2luZyA/PyB7fSxcbiAgICB9O1xuICB9O1xuXG4gIHByaXZhdGUgcmVzb2x2ZU5hbWUgPSAoKSA9PiB7XG4gICAgLy8gSWYgbmFtZSBpcyBzZXQgZXhwbGljaXRseSwgdXNlIHRoYXRcbiAgICBpZiAodGhpcy5wcm9wcy5uYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5uYW1lO1xuICAgIH1cbiAgICAvLyBJZiBlbnRyeSBpcyBzZXQsIHVzZSB0aGUgYmFzZW5hbWUgb2YgdGhlIGVudHJ5IHBhdGhcbiAgICBpZiAodGhpcy5wcm9wcy5lbnRyeSkge1xuICAgICAgcmV0dXJuIHBhdGgucGFyc2UodGhpcy5wcm9wcy5lbnRyeSkubmFtZTtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIHVzZSB0aGUgZGlyZWN0b3J5IG5hbWUgd2hlcmUgdGhlIGZ1bmN0aW9uIGlzIGRlZmluZWRcbiAgICByZXR1cm4gcGF0aC5iYXNlbmFtZShcbiAgICAgIG5ldyBDYWxsZXJEaXJlY3RvcnlFeHRyYWN0b3IodGhpcy5jYWxsZXJTdGFjaykuZXh0cmFjdCgpXG4gICAgKTtcbiAgfTtcblxuICBwcml2YXRlIHJlc29sdmVFbnRyeSA9ICgpID0+IHtcbiAgICAvLyBpZiBlbnRyeSBpcyBub3Qgc2V0LCBkZWZhdWx0IHRvIGhhbmRsZXIudHNcbiAgICBpZiAoIXRoaXMucHJvcHMuZW50cnkpIHtcbiAgICAgIHJldHVybiBwYXRoLmpvaW4oXG4gICAgICAgIG5ldyBDYWxsZXJEaXJlY3RvcnlFeHRyYWN0b3IodGhpcy5jYWxsZXJTdGFjaykuZXh0cmFjdCgpLFxuICAgICAgICAnaGFuZGxlci50cydcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gaWYgZW50cnkgaXMgYWJzb2x1dGUgdXNlIHRoYXRcbiAgICBpZiAocGF0aC5pc0Fic29sdXRlKHRoaXMucHJvcHMuZW50cnkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5lbnRyeTtcbiAgICB9XG5cbiAgICAvLyBpZiBlbnRyeSBpcyByZWxhdGl2ZSwgY29tcHV0ZSB3aXRoIHJlc3BlY3QgdG8gdGhlIGNhbGxlciBkaXJlY3RvcnlcbiAgICByZXR1cm4gcGF0aC5qb2luKFxuICAgICAgbmV3IENhbGxlckRpcmVjdG9yeUV4dHJhY3Rvcih0aGlzLmNhbGxlclN0YWNrKS5leHRyYWN0KCksXG4gICAgICB0aGlzLnByb3BzLmVudHJ5XG4gICAgKTtcbiAgfTtcblxuICBwcml2YXRlIHJlc29sdmVUaW1lb3V0ID0gKCkgPT4ge1xuICAgIGNvbnN0IHRpbWVvdXRNaW4gPSAxO1xuICAgIGNvbnN0IHRpbWVvdXRNYXggPSA2MCAqIDE1OyAvLyAxNSBtaW51dGVzIGluIHNlY29uZHNcbiAgICBjb25zdCB0aW1lb3V0RGVmYXVsdCA9IDM7XG4gICAgaWYgKHRoaXMucHJvcHMudGltZW91dFNlY29uZHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRpbWVvdXREZWZhdWx0O1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgICFpc1dob2xlTnVtYmVyQmV0d2VlbkluY2x1c2l2ZShcbiAgICAgICAgdGhpcy5wcm9wcy50aW1lb3V0U2Vjb25kcyxcbiAgICAgICAgdGltZW91dE1pbixcbiAgICAgICAgdGltZW91dE1heFxuICAgICAgKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEFtcGxpZnlVc2VyRXJyb3IoJ0ludmFsaWRUaW1lb3V0RXJyb3InLCB7XG4gICAgICAgIG1lc3NhZ2U6IGBJbnZhbGlkIGZ1bmN0aW9uIHRpbWVvdXQgb2YgJHt0aGlzLnByb3BzLnRpbWVvdXRTZWNvbmRzfWAsXG4gICAgICAgIHJlc29sdXRpb246IGB0aW1lb3V0U2Vjb25kcyBtdXN0IGJlIGEgd2hvbGUgbnVtYmVyIGJldHdlZW4gJHt0aW1lb3V0TWlufSBhbmQgJHt0aW1lb3V0TWF4fSBpbmNsdXNpdmVgLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByb3BzLnRpbWVvdXRTZWNvbmRzO1xuICB9O1xuXG4gIHByaXZhdGUgcmVzb2x2ZU1lbW9yeSA9ICgpID0+IHtcbiAgICBjb25zdCBtZW1vcnlNaW4gPSAxMjg7XG4gICAgY29uc3QgbWVtb3J5TWF4ID0gMTAyNDA7XG4gICAgY29uc3QgbWVtb3J5RGVmYXVsdCA9IDUxMjtcbiAgICBpZiAodGhpcy5wcm9wcy5tZW1vcnlNQiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbWVtb3J5RGVmYXVsdDtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgIWlzV2hvbGVOdW1iZXJCZXR3ZWVuSW5jbHVzaXZlKHRoaXMucHJvcHMubWVtb3J5TUIsIG1lbW9yeU1pbiwgbWVtb3J5TWF4KVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEFtcGxpZnlVc2VyRXJyb3IoJ0ludmFsaWRNZW1vcnlNQkVycm9yJywge1xuICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCBmdW5jdGlvbiBtZW1vcnlNQiBvZiAke3RoaXMucHJvcHMubWVtb3J5TUJ9YCxcbiAgICAgICAgcmVzb2x1dGlvbjogYG1lbW9yeU1CIG11c3QgYmUgYSB3aG9sZSBudW1iZXIgYmV0d2VlbiAke21lbW9yeU1pbn0gYW5kICR7bWVtb3J5TWF4fSBpbmNsdXNpdmVgLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByb3BzLm1lbW9yeU1CO1xuICB9O1xuXG4gIHByaXZhdGUgcmVzb2x2ZUVudmlyb25tZW50ID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLnByb3BzLmVudmlyb25tZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnZhbGlkS2V5czogc3RyaW5nW10gPSBbXTtcblxuICAgIE9iamVjdC5rZXlzKHRoaXMucHJvcHMuZW52aXJvbm1lbnQpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgLy8gdmFsaWRhdGUgdXNpbmcga2V5IHBhdHRlcm4gZnJvbSBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vbGFtYmRhL2xhdGVzdC9hcGkvQVBJX0Vudmlyb25tZW50Lmh0bWxcbiAgICAgIGlmICgha2V5Lm1hdGNoKC9eW2EtekEtWl0oW2EtekEtWjAtOV9dKSskLykpIHtcbiAgICAgICAgaW52YWxpZEtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGludmFsaWRLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBBbXBsaWZ5VXNlckVycm9yKCdJbnZhbGlkRW52aXJvbm1lbnRLZXlFcnJvcicsIHtcbiAgICAgICAgbWVzc2FnZTogYEludmFsaWQgZnVuY3Rpb24gZW52aXJvbm1lbnQga2V5KHMpOiAke2ludmFsaWRLZXlzLmpvaW4oXG4gICAgICAgICAgJywgJ1xuICAgICAgICApfWAsXG4gICAgICAgIHJlc29sdXRpb246XG4gICAgICAgICAgJ0Vudmlyb25tZW50IGtleXMgbXVzdCBtYXRjaCBbYS16QS1aXShbYS16QS1aMC05X10pKyBhbmQgYmUgYXQgbGVhc3QgMiBjaGFyYWN0ZXJzJyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnByb3BzLmVudmlyb25tZW50O1xuICB9O1xuXG4gIHByaXZhdGUgcmVzb2x2ZVJ1bnRpbWUgPSAoKSA9PiB7XG4gICAgY29uc3QgcnVudGltZURlZmF1bHQgPSAxODtcblxuICAgIC8vIGlmIHJ1bnRpbWUgaXMgbm90IHNldCwgZGVmYXVsdCB0byB0aGUgb2xkZXN0IExUU1xuICAgIGlmICghdGhpcy5wcm9wcy5ydW50aW1lKSB7XG4gICAgICByZXR1cm4gcnVudGltZURlZmF1bHQ7XG4gICAgfVxuXG4gICAgaWYgKCEodGhpcy5wcm9wcy5ydW50aW1lIGluIG5vZGVWZXJzaW9uTWFwKSkge1xuICAgICAgdGhyb3cgbmV3IEFtcGxpZnlVc2VyRXJyb3IoJ0ludmFsaWRSdW50aW1lRXJyb3InLCB7XG4gICAgICAgIG1lc3NhZ2U6IGBJbnZhbGlkIGZ1bmN0aW9uIHJ1bnRpbWUgb2YgJHt0aGlzLnByb3BzLnJ1bnRpbWV9YCxcbiAgICAgICAgcmVzb2x1dGlvbjogYHJ1bnRpbWUgbXVzdCBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZzogJHtPYmplY3Qua2V5cyhcbiAgICAgICAgICBub2RlVmVyc2lvbk1hcFxuICAgICAgICApLmpvaW4oJywgJyl9YCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnByb3BzLnJ1bnRpbWU7XG4gIH07XG5cbiAgcHJpdmF0ZSByZXNvbHZlU2NoZWR1bGUgPSAoKSA9PiB7XG4gICAgaWYgKCF0aGlzLnByb3BzLnNjaGVkdWxlKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucHJvcHMuc2NoZWR1bGU7XG4gIH07XG5cbiAgcHJpdmF0ZSByZXNvbHZlQnVuZGxpbmcgPSAoKSA9PiB7XG4gICAgY29uc3QgYnVuZGxpbmdEZWZhdWx0ID0ge1xuICAgICAgZm9ybWF0OiBPdXRwdXRGb3JtYXQuRVNNLFxuICAgICAgYnVuZGxlQXdzU0RLOiB0cnVlLFxuICAgICAgbG9hZGVyOiB7XG4gICAgICAgICcubm9kZSc6ICdmaWxlJyxcbiAgICAgIH0sXG4gICAgICBtaW5pZnk6IHRydWUsXG4gICAgICBzb3VyY2VNYXA6IHRydWUsXG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5idW5kbGluZ0RlZmF1bHQsXG4gICAgICBtaW5pZnk6IHRoaXMucmVzb2x2ZU1pbmlmeSh0aGlzLnByb3BzLmJ1bmRsaW5nKSxcbiAgICB9O1xuICB9O1xuXG4gIHByaXZhdGUgcmVzb2x2ZU1pbmlmeSA9IChidW5kbGluZz86IEZ1bmN0aW9uQnVuZGxpbmdPcHRpb25zKSA9PiB7XG4gICAgcmV0dXJuIGJ1bmRsaW5nPy5taW5pZnkgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBidW5kbGluZy5taW5pZnk7XG4gIH07XG59XG5cbnR5cGUgSHlkcmF0ZWRGdW5jdGlvblByb3BzID0gUmVxdWlyZWQ8RnVuY3Rpb25Qcm9wcz47XG5cbmNsYXNzIEZ1bmN0aW9uR2VuZXJhdG9yIGltcGxlbWVudHMgQ29uc3RydWN0Q29udGFpbmVyRW50cnlHZW5lcmF0b3Ige1xuICByZWFkb25seSByZXNvdXJjZUdyb3VwTmFtZTogQW1wbGlmeVJlc291cmNlR3JvdXBOYW1lO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcHJvcHM6IEh5ZHJhdGVkRnVuY3Rpb25Qcm9wcyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IG91dHB1dFN0b3JhZ2VTdHJhdGVneTogQmFja2VuZE91dHB1dFN0b3JhZ2VTdHJhdGVneTxGdW5jdGlvbk91dHB1dD5cbiAgKSB7XG4gICAgdGhpcy5yZXNvdXJjZUdyb3VwTmFtZSA9IHByb3BzLnJlc291cmNlR3JvdXBOYW1lO1xuICB9XG5cbiAgZ2VuZXJhdGVDb250YWluZXJFbnRyeSA9ICh7XG4gICAgc2NvcGUsXG4gICAgYmFja2VuZFNlY3JldFJlc29sdmVyLFxuICB9OiBHZW5lcmF0ZUNvbnRhaW5lckVudHJ5UHJvcHMpID0+IHtcbiAgICAvLyByZXNvbHZlIGxheWVycyB0byBMYXllclZlcnNpb24gb2JqZWN0cyBmb3IgdGhlIE5vZGVqc0Z1bmN0aW9uIGNvbnN0cnVjdG9yIHVzaW5nIHRoZSBzY29wZS5cbiAgICBjb25zdCByZXNvbHZlZExheWVycyA9IE9iamVjdC5lbnRyaWVzKHRoaXMucHJvcHMubGF5ZXJzKS5tYXAoKFtrZXksIGFybl0pID0+XG4gICAgICBMYXllclZlcnNpb24uZnJvbUxheWVyVmVyc2lvbkFybihcbiAgICAgICAgc2NvcGUsXG4gICAgICAgIGAke3RoaXMucHJvcHMubmFtZX0tJHtrZXl9LWxheWVyYCxcbiAgICAgICAgYXJuXG4gICAgICApXG4gICAgKTtcblxuICAgIHJldHVybiBuZXcgQW1wbGlmeUZ1bmN0aW9uKFxuICAgICAgc2NvcGUsXG4gICAgICB0aGlzLnByb3BzLm5hbWUsXG4gICAgICB7IC4uLnRoaXMucHJvcHMsIHJlc29sdmVkTGF5ZXJzIH0sXG4gICAgICBiYWNrZW5kU2VjcmV0UmVzb2x2ZXIsXG4gICAgICB0aGlzLm91dHB1dFN0b3JhZ2VTdHJhdGVneVxuICAgICk7XG4gIH07XG59XG5cbmNsYXNzIEFtcGxpZnlGdW5jdGlvblxuICBleHRlbmRzIENvbnN0cnVjdFxuICBpbXBsZW1lbnRzXG4gICAgUmVzb3VyY2VQcm92aWRlcjxGdW5jdGlvblJlc291cmNlcz4sXG4gICAgUmVzb3VyY2VBY2Nlc3NBY2NlcHRvckZhY3RvcnksXG4gICAgQWRkRW52aXJvbm1lbnRGYWN0b3J5XG57XG4gIHJlYWRvbmx5IHJlc291cmNlczogRnVuY3Rpb25SZXNvdXJjZXM7XG4gIHJlYWRvbmx5IHN0YWNrOiBTdGFjaztcbiAgcHJpdmF0ZSByZWFkb25seSBmdW5jdGlvbkVudmlyb25tZW50VHJhbnNsYXRvcjogRnVuY3Rpb25FbnZpcm9ubWVudFRyYW5zbGF0b3I7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHNjb3BlOiBDb25zdHJ1Y3QsXG4gICAgaWQ6IHN0cmluZyxcbiAgICBwcm9wczogSHlkcmF0ZWRGdW5jdGlvblByb3BzICYgeyByZXNvbHZlZExheWVyczogSUxheWVyVmVyc2lvbltdIH0sXG4gICAgYmFja2VuZFNlY3JldFJlc29sdmVyOiBCYWNrZW5kU2VjcmV0UmVzb2x2ZXIsXG4gICAgb3V0cHV0U3RvcmFnZVN0cmF0ZWd5OiBCYWNrZW5kT3V0cHV0U3RvcmFnZVN0cmF0ZWd5PEZ1bmN0aW9uT3V0cHV0PlxuICApIHtcbiAgICBzdXBlcihzY29wZSwgaWQpO1xuXG4gICAgdGhpcy5zdGFjayA9IFN0YWNrLm9mKHNjb3BlKTtcblxuICAgIGNvbnN0IHJ1bnRpbWUgPSBub2RlVmVyc2lvbk1hcFtwcm9wcy5ydW50aW1lXTtcblxuICAgIGNvbnN0IHJlcXVpcmUgPSBjcmVhdGVSZXF1aXJlKGltcG9ydC5tZXRhLnVybCk7XG5cbiAgICBjb25zdCBzaGltcyA9XG4gICAgICBydW50aW1lID09PSBSdW50aW1lLk5PREVKU18xNl9YXG4gICAgICAgID8gW11cbiAgICAgICAgOiBbcmVxdWlyZS5yZXNvbHZlKCcuL2xhbWJkYS1zaGltcy9janNfc2hpbScpXTtcblxuICAgIGNvbnN0IHNzbVJlc29sdmVyRmlsZSA9XG4gICAgICBydW50aW1lID09PSBSdW50aW1lLk5PREVKU18xNl9YXG4gICAgICAgID8gcmVxdWlyZS5yZXNvbHZlKCcuL2xhbWJkYS1zaGltcy9yZXNvbHZlX3NzbV9wYXJhbXNfc2RrX3YyJykgLy8gdXNlIGF3cyBjZGsgdjIgaW4gbm9kZSAxNlxuICAgICAgICA6IHJlcXVpcmUucmVzb2x2ZSgnLi9sYW1iZGEtc2hpbXMvcmVzb2x2ZV9zc21fcGFyYW1zJyk7XG5cbiAgICBjb25zdCBpbnZva2VTc21SZXNvbHZlckZpbGUgPSByZXF1aXJlLnJlc29sdmUoXG4gICAgICAnLi9sYW1iZGEtc2hpbXMvaW52b2tlX3NzbV9zaGltJ1xuICAgICk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGNvZGUgY29uY2F0ZW5hdGVzIHRoZSBjb250ZW50cyBvZiB0aGUgc3NtIHJlc29sdmVyIGFuZCBpbnZva2VyIGludG8gYSBzaW5nbGUgbGluZSB0aGF0IGNhbiBiZSB1c2VkIGFzIHRoZSBlc2J1aWxkIGJhbm5lciBjb250ZW50XG4gICAgICogVGhpcyBiYW5uZXIgaXMgcmVzcG9uc2libGUgZm9yIHJlc29sdmluZyB0aGUgY3VzdG9tZXIncyBTU00gcGFyYW1ldGVycyBhdCBydW50aW1lXG4gICAgICovXG4gICAgY29uc3QgYmFubmVyQ29kZSA9IHJlYWRGaWxlU3luYyhzc21SZXNvbHZlckZpbGUsICd1dGYtOCcpXG4gICAgICAuY29uY2F0KHJlYWRGaWxlU3luYyhpbnZva2VTc21SZXNvbHZlckZpbGUsICd1dGYtOCcpKVxuICAgICAgLnNwbGl0KG5ldyBSZWdFeHAoYCR7RU9MfXxcXG58XFxyYCwgJ2cnKSlcbiAgICAgIC5tYXAoKGxpbmUpID0+IGxpbmUucmVwbGFjZSgvXFwvXFwvLiokLywgJycpKSAvLyBzdHJpcCBvdXQgaW5saW5lIGNvbW1lbnRzIGJlY2F1c2UgdGhlIGJhbm5lciBpcyBnb2luZyB0byBiZSBmbGF0dGVuZWQgaW50byBhIHNpbmdsZSBsaW5lXG4gICAgICAuam9pbignJyk7XG5cbiAgICBjb25zdCBmdW5jdGlvbkVudmlyb25tZW50VHlwZUdlbmVyYXRvciA9XG4gICAgICBuZXcgRnVuY3Rpb25FbnZpcm9ubWVudFR5cGVHZW5lcmF0b3IoaWQpO1xuXG4gICAgLy8gZXNidWlsZCBydW5zIGFzIHBhcnQgb2YgdGhlIE5vZGVqc0Z1bmN0aW9uIGNvbnN0cnVjdG9yLCBzbyB3ZSBlYWdlcmx5IGdlbmVyYXRlIHRoZSBwcm9jZXNzIGVudiBzaGltIHdpdGhvdXQgdHlwZXMgc28gaXQgY2FuIGJlIGluY2x1ZGVkIGluIHRoZSBmdW5jdGlvbiBidW5kbGUuXG4gICAgLy8gVGhpcyB3aWxsIGJlIG92ZXJ3cml0dGVuIHdpdGggdGhlIHR5cGVkIGZpbGUgYXQgdGhlIGVuZCBvZiBzeW50aGVzaXNcbiAgICBmdW5jdGlvbkVudmlyb25tZW50VHlwZUdlbmVyYXRvci5nZW5lcmF0ZVByb2Nlc3NFbnZTaGltKCk7XG5cbiAgICBsZXQgZnVuY3Rpb25MYW1iZGE6IE5vZGVqc0Z1bmN0aW9uO1xuICAgIGNvbnN0IGNka0xvZ2dpbmdPcHRpb25zID0gY29udmVydExvZ2dpbmdPcHRpb25zVG9DREsocHJvcHMubG9nZ2luZyk7XG4gICAgdHJ5IHtcbiAgICAgIGZ1bmN0aW9uTGFtYmRhID0gbmV3IE5vZGVqc0Z1bmN0aW9uKHNjb3BlLCBgJHtpZH0tbGFtYmRhYCwge1xuICAgICAgICBlbnRyeTogcHJvcHMuZW50cnksXG4gICAgICAgIHRpbWVvdXQ6IER1cmF0aW9uLnNlY29uZHMocHJvcHMudGltZW91dFNlY29uZHMpLFxuICAgICAgICBtZW1vcnlTaXplOiBwcm9wcy5tZW1vcnlNQixcbiAgICAgICAgcnVudGltZTogbm9kZVZlcnNpb25NYXBbcHJvcHMucnVudGltZV0sXG4gICAgICAgIGxheWVyczogcHJvcHMucmVzb2x2ZWRMYXllcnMsXG4gICAgICAgIGJ1bmRsaW5nOiB7XG4gICAgICAgICAgLi4ucHJvcHMuYnVuZGxpbmcsXG4gICAgICAgICAgYmFubmVyOiBiYW5uZXJDb2RlLFxuICAgICAgICAgIGluamVjdDogc2hpbXMsXG4gICAgICAgICAgZXh0ZXJuYWxNb2R1bGVzOiBPYmplY3Qua2V5cyhwcm9wcy5sYXllcnMpLFxuICAgICAgICB9LFxuICAgICAgICBsb2dSZXRlbnRpb246IGNka0xvZ2dpbmdPcHRpb25zLnJldGVudGlvbixcbiAgICAgICAgYXBwbGljYXRpb25Mb2dMZXZlbFYyOiBjZGtMb2dnaW5nT3B0aW9ucy5sZXZlbCxcbiAgICAgICAgbG9nZ2luZ0Zvcm1hdDogY2RrTG9nZ2luZ09wdGlvbnMuZm9ybWF0LFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIElmIHRoZSBlcnJvciBpcyBmcm9tIEVTIEJ1bmRsZXIgd2hpY2ggaXMgZXhlY3V0ZWQgYXMgYSBjaGlsZCBwcm9jZXNzIGJ5IENESyxcbiAgICAgIC8vIHRoZW4gdGhlIGVycm9yIGZyb20gQ0RLIGNvbnRhaW5zIHRoZSBjb21tYW5kIHRoYXQgd2FzIGV4ZWN1dGVkIGFsb25nIHdpdGggdGhlIGV4aXQgc3RhdHVzLlxuICAgICAgLy8gV3JhcHBpbmcgaXQgaGVyZSAgd291bGQgY2F1c2UgdGhlIGNka19kZXBsb3llciB0byByZS10aHJvdyB0aGlzIHdyYXBwZWQgZXhjZXB0aW9uXG4gICAgICAvLyBpbnN0ZWFkIG9mIHNjcmFwaW5nIHRoZSBzdGRlcnIgZm9yIGFjdHVhbCBFU0J1aWxkIGVycm9yLlxuICAgICAgaWYgKFxuICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmXG4gICAgICAgIGVycm9yLm1lc3NhZ2UubWF0Y2goL0ZhaWxlZCB0byBidW5kbGUgYXNzZXQuKmV4aXRlZCB3aXRoIHN0YXR1cy8pXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQW1wbGlmeVVzZXJFcnJvcihcbiAgICAgICAgJ05vZGVKU0Z1bmN0aW9uQ29uc3RydWN0SW5pdGlhbGl6YXRpb25FcnJvcicsXG4gICAgICAgIHtcbiAgICAgICAgICBtZXNzYWdlOiAnRmFpbGVkIHRvIGluc3RhbnRpYXRlIG5vZGVqcyBmdW5jdGlvbiBjb25zdHJ1Y3QnLFxuICAgICAgICAgIHJlc29sdXRpb246XG4gICAgICAgICAgICAnU2VlIHRoZSB1bmRlcmx5aW5nIGVycm9yIG1lc3NhZ2UgZm9yIG1vcmUgZGV0YWlscy4gVXNlIGAtLWRlYnVnYCBmb3IgYWRkaXRpb25hbCBkZWJ1Z2dpbmcgaW5mb3JtYXRpb24uJyxcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3IgYXMgRXJyb3JcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNjaGVkdWxlcyA9IGNvbnZlcnRGdW5jdGlvblNjaGVkdWxlc1RvUnVsZVNjaGVkdWxlcyhcbiAgICAgICAgZnVuY3Rpb25MYW1iZGEsXG4gICAgICAgIHByb3BzLnNjaGVkdWxlXG4gICAgICApO1xuICAgICAgY29uc3QgbGFtYmRhVGFyZ2V0ID0gbmV3IHRhcmdldHMuTGFtYmRhRnVuY3Rpb24oZnVuY3Rpb25MYW1iZGEpO1xuXG4gICAgICBzY2hlZHVsZXMuZm9yRWFjaCgoc2NoZWR1bGUsIGluZGV4KSA9PiB7XG4gICAgICAgIC8vIExhbWJkYSBuYW1lIHdpbGwgYmUgcHJlcGVuZGVkIHRvIHJ1bGUgaWQsIHNvIG9ubHkgdXNpbmcgaW5kZXggaGVyZSBmb3IgdW5pcXVlbmVzc1xuICAgICAgICBjb25zdCBydWxlID0gbmV3IFJ1bGUoZnVuY3Rpb25MYW1iZGEsIGBzY2hlZHVsZSR7aW5kZXh9YCwge1xuICAgICAgICAgIHNjaGVkdWxlLFxuICAgICAgICB9KTtcblxuICAgICAgICBydWxlLmFkZFRhcmdldChsYW1iZGFUYXJnZXQpO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBBbXBsaWZ5VXNlckVycm9yKFxuICAgICAgICAnRnVuY3Rpb25TY2hlZHVsZUluaXRpYWxpemF0aW9uRXJyb3InLFxuICAgICAgICB7XG4gICAgICAgICAgbWVzc2FnZTogJ0ZhaWxlZCB0byBpbnN0YW50aWF0ZSBzY2hlZHVsZSBmb3Igbm9kZWpzIGZ1bmN0aW9uJyxcbiAgICAgICAgICByZXNvbHV0aW9uOiAnU2VlIHRoZSB1bmRlcmx5aW5nIGVycm9yIG1lc3NhZ2UgZm9yIG1vcmUgZGV0YWlscy4nLFxuICAgICAgICB9LFxuICAgICAgICBlcnJvciBhcyBFcnJvclxuICAgICAgKTtcbiAgICB9XG5cbiAgICBUYWdzLm9mKGZ1bmN0aW9uTGFtYmRhKS5hZGQoVGFnTmFtZS5GUklFTkRMWV9OQU1FLCBpZCk7XG5cbiAgICB0aGlzLmZ1bmN0aW9uRW52aXJvbm1lbnRUcmFuc2xhdG9yID0gbmV3IEZ1bmN0aW9uRW52aXJvbm1lbnRUcmFuc2xhdG9yKFxuICAgICAgZnVuY3Rpb25MYW1iZGEsXG4gICAgICBwcm9wcy5lbnZpcm9ubWVudCxcbiAgICAgIGJhY2tlbmRTZWNyZXRSZXNvbHZlcixcbiAgICAgIGZ1bmN0aW9uRW52aXJvbm1lbnRUeXBlR2VuZXJhdG9yXG4gICAgKTtcblxuICAgIHRoaXMucmVzb3VyY2VzID0ge1xuICAgICAgbGFtYmRhOiBmdW5jdGlvbkxhbWJkYSxcbiAgICAgIGNmblJlc291cmNlczoge1xuICAgICAgICBjZm5GdW5jdGlvbjogZnVuY3Rpb25MYW1iZGEubm9kZS5maW5kQ2hpbGQoJ1Jlc291cmNlJykgYXMgQ2ZuRnVuY3Rpb24sXG4gICAgICB9LFxuICAgIH07XG5cbiAgICB0aGlzLnN0b3JlT3V0cHV0KG91dHB1dFN0b3JhZ2VTdHJhdGVneSk7XG5cbiAgICBuZXcgQXR0cmlidXRpb25NZXRhZGF0YVN0b3JhZ2UoKS5zdG9yZUF0dHJpYnV0aW9uTWV0YWRhdGEoXG4gICAgICBTdGFjay5vZih0aGlzKSxcbiAgICAgIGZ1bmN0aW9uU3RhY2tUeXBlLFxuICAgICAgZmlsZVVSTFRvUGF0aChuZXcgVVJMKCcuLi9wYWNrYWdlLmpzb24nLCBpbXBvcnQubWV0YS51cmwpKVxuICAgICk7XG4gIH1cblxuICBhZGRFbnZpcm9ubWVudCA9IChrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IEJhY2tlbmRTZWNyZXQpID0+IHtcbiAgICB0aGlzLmZ1bmN0aW9uRW52aXJvbm1lbnRUcmFuc2xhdG9yLmFkZEVudmlyb25tZW50RW50cnkoa2V5LCB2YWx1ZSk7XG4gIH07XG5cbiAgZ2V0UmVzb3VyY2VBY2Nlc3NBY2NlcHRvciA9ICgpID0+ICh7XG4gICAgaWRlbnRpZmllcjogYCR7dGhpcy5ub2RlLmlkfUxhbWJkYVJlc291cmNlQWNjZXNzQWNjZXB0b3JgLFxuICAgIGFjY2VwdFJlc291cmNlQWNjZXNzOiAoXG4gICAgICBwb2xpY3k6IFBvbGljeSxcbiAgICAgIHNzbUVudmlyb25tZW50RW50cmllczogU3NtRW52aXJvbm1lbnRFbnRyeVtdXG4gICAgKSA9PiB7XG4gICAgICBjb25zdCByb2xlID0gdGhpcy5yZXNvdXJjZXMubGFtYmRhLnJvbGU7XG4gICAgICBpZiAoIXJvbGUpIHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuIHNpbmNlIHdlIGFyZSB1c2luZyB0aGUgRnVuY3Rpb24gTDIgY29uc3RydWN0XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnTm8gZXhlY3V0aW9uIHJvbGUgZm91bmQgdG8gYXR0YWNoIGxhbWJkYSBwZXJtaXNzaW9ucyB0bydcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHBvbGljeS5hdHRhY2hUb1JvbGUocm9sZSk7XG4gICAgICBzc21FbnZpcm9ubWVudEVudHJpZXMuZm9yRWFjaCgoeyBuYW1lLCBwYXRoIH0pID0+IHtcbiAgICAgICAgdGhpcy5mdW5jdGlvbkVudmlyb25tZW50VHJhbnNsYXRvci5hZGRTc21FbnZpcm9ubWVudEVudHJ5KG5hbWUsIHBhdGgpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFN0b3JlIHN0b3JhZ2Ugb3V0cHV0cyB1c2luZyBwcm92aWRlZCBzdHJhdGVneVxuICAgKi9cbiAgcHJpdmF0ZSBzdG9yZU91dHB1dCA9IChcbiAgICBvdXRwdXRTdG9yYWdlU3RyYXRlZ3k6IEJhY2tlbmRPdXRwdXRTdG9yYWdlU3RyYXRlZ3k8RnVuY3Rpb25PdXRwdXQ+XG4gICk6IHZvaWQgPT4ge1xuICAgIG91dHB1dFN0b3JhZ2VTdHJhdGVneS5hcHBlbmRUb0JhY2tlbmRPdXRwdXRMaXN0KGZ1bmN0aW9uT3V0cHV0S2V5LCB7XG4gICAgICB2ZXJzaW9uOiAnMScsXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIGRlZmluZWRGdW5jdGlvbnM6IHRoaXMucmVzb3VyY2VzLmxhbWJkYS5mdW5jdGlvbk5hbWUsXG4gICAgICB9LFxuICAgIH0pO1xuICB9O1xufVxuXG5jb25zdCBpc1dob2xlTnVtYmVyQmV0d2VlbkluY2x1c2l2ZSA9IChcbiAgdGVzdDogbnVtYmVyLFxuICBtaW46IG51bWJlcixcbiAgbWF4OiBudW1iZXJcbikgPT4gbWluIDw9IHRlc3QgJiYgdGVzdCA8PSBtYXggJiYgdGVzdCAlIDEgPT09IDA7XG5cbmV4cG9ydCB0eXBlIE5vZGVWZXJzaW9uID0gMTYgfCAxOCB8IDIwIHwgMjI7XG5cbmNvbnN0IG5vZGVWZXJzaW9uTWFwOiBSZWNvcmQ8Tm9kZVZlcnNpb24sIFJ1bnRpbWU+ID0ge1xuICAxNjogUnVudGltZS5OT0RFSlNfMTZfWCxcbiAgMTg6IFJ1bnRpbWUuTk9ERUpTXzE4X1gsXG4gIDIwOiBSdW50aW1lLk5PREVKU18yMF9YLFxuICAyMjogUnVudGltZS5OT0RFSlNfMjJfWCxcbn07XG4iXX0=