import stream from 'stream';
import readline from 'readline';
import { AmplifyError, AmplifyUserError, CDKContextKey, } from '@aws-amplify/platform-core';
import { dirname } from 'path';
/**
 * Commands that can be invoked
 */
var InvokableCommand;
(function (InvokableCommand) {
    InvokableCommand["DEPLOY"] = "deploy";
    InvokableCommand["DESTROY"] = "destroy";
    InvokableCommand["SYNTH"] = "synth";
})(InvokableCommand || (InvokableCommand = {}));
/**
 * Invokes CDK command via execa
 */
export class CDKDeployer {
    cdkErrorMapper;
    backendLocator;
    packageManagerController;
    relativeCloudAssemblyLocation = '.amplify/artifacts/cdk.out';
    /**
     * Instantiates instance of CDKDeployer
     */
    constructor(cdkErrorMapper, backendLocator, packageManagerController) {
        this.cdkErrorMapper = cdkErrorMapper;
        this.backendLocator = backendLocator;
        this.packageManagerController = packageManagerController;
    }
    /**
     * Invokes cdk deploy command
     */
    deploy = async (backendId, deployProps) => {
        const cdkCommandArgs = [];
        if (backendId.type === 'sandbox') {
            cdkCommandArgs.push('--hotswap-fallback');
            cdkCommandArgs.push('--method=direct');
            if (deployProps?.secretLastUpdated) {
                cdkCommandArgs.push('--context', `secretLastUpdated=${deployProps.secretLastUpdated.getTime()}`);
            }
        }
        if (deployProps?.profile) {
            cdkCommandArgs.push('--profile', deployProps.profile);
        }
        // first synth with the backend definition but suppress any errors.
        // We want to show errors from the TS compiler rather than the ESBuild as
        // TS errors are more relevant (Library validations are type reliant).
        const startTime = Date.now();
        let synthError = undefined;
        try {
            await this.tryInvokeCdk(InvokableCommand.SYNTH, backendId, this.getAppCommand(), cdkCommandArgs.concat('--quiet') // don't print the CFN template to stdout
            );
        }
        catch (e) {
            synthError = e;
        }
        // CDK prints synth time in seconds rounded to 2 decimal places. Here we duplicate that behavior.
        const synthTimeSeconds = Math.floor((Date.now() - startTime) / 10) / 100;
        // then run type checks
        try {
            await this.invokeTsc(deployProps);
        }
        catch (typeError) {
            if (synthError &&
                AmplifyError.isAmplifyError(typeError) &&
                typeError.cause?.message.match(/Cannot find module '\$amplify\/env\/.*' or its corresponding type declarations/)) {
                // synth has failed and we don't have auto generated function environment definition files. This
                // resulted in the exception caught here, which is not very useful for the customers.
                // We instead throw the synth error for customers to fix what caused the synth to fail.
                throw synthError;
            }
            throw typeError;
        }
        // If somehow TSC was successful but synth wasn't, we now throw to surface the synth error
        if (synthError) {
            throw synthError;
        }
        // then deploy with the cloud assembly that was generated during synth
        const deployResult = await this.tryInvokeCdk(InvokableCommand.DEPLOY, backendId, this.relativeCloudAssemblyLocation, cdkCommandArgs);
        return {
            deploymentTimes: {
                synthesisTime: synthTimeSeconds,
                totalTime: synthTimeSeconds + (deployResult?.deploymentTimes?.totalTime || 0),
            },
        };
    };
    /**
     * Invokes cdk destroy command
     */
    destroy = async (backendId, destroyProps) => {
        const cdkCommandArgs = ['--force'];
        if (destroyProps?.profile) {
            cdkCommandArgs.push('--profile', destroyProps.profile);
        }
        return this.tryInvokeCdk(InvokableCommand.DESTROY, backendId, this.getAppCommand(), cdkCommandArgs);
    };
    /**
     * Wrapper for the child process executor. Helps in unit testing as node:test framework
     * doesn't have capabilities to mock exported functions like `execa` as of right now.
     */
    executeCommand = async (commandArgs, options = {
        redirectStdoutToStderr: false,
    }) => {
        // We let the stdout and stdin inherit and streamed to parent process but pipe
        // the stderr and use it to throw on failure. This is to prevent actual
        // actionable errors being hidden among the stdout. Moreover execa errors are
        // useless when calling CLIs unless you made execa calling error.
        let aggregatedStderr = '';
        const aggregatorStderrStream = new stream.Writable();
        aggregatorStderrStream._write = function (chunk, encoding, done) {
            aggregatedStderr += chunk;
            done();
        };
        const childProcess = this.packageManagerController.runWithPackageManager(commandArgs, process.cwd(), {
            stdin: 'inherit',
            stdout: 'pipe',
            stderr: 'pipe',
            // Piping the output by default strips off the color. This is a workaround to
            // preserve the color being piped to parent process.
            extendEnv: true,
            env: { FORCE_COLOR: '1' },
        });
        childProcess.stderr?.pipe(aggregatorStderrStream);
        if (options?.redirectStdoutToStderr) {
            childProcess.stdout?.pipe(aggregatorStderrStream);
        }
        else {
            childProcess.stdout?.pipe(process.stdout);
        }
        const cdkOutput = { deploymentTimes: {} };
        if (childProcess.stdout) {
            await this.populateCDKOutputFromStdout(cdkOutput, childProcess.stdout);
        }
        try {
            await childProcess;
            return cdkOutput;
        }
        catch (error) {
            // swallow execa error if the cdk cli ran and produced some stderr.
            // Most of the time this error is noise(basically child exited with exit code...)
            // bubbling this up to customers add confusion (Customers don't need to know we are running IPC calls
            // and their exit codes printed while sandbox continue to run). Hence we explicitly don't pass error in the cause
            // rather throw the entire stderr for clients to figure out what to do with it.
            // However if the cdk process didn't run or produced no output, then we have nothing to go on with. So we throw
            // this error to aid in some debugging.
            if (aggregatedStderr.trim()) {
                // If the string is more than 65KB, truncate and keep the last portion.
                // eslint-disable-next-line amplify-backend-rules/prefer-amplify-errors
                throw new Error(this.truncateString(aggregatedStderr, 65000));
            }
            else {
                throw error;
            }
        }
    };
    truncateString = (str, size) => {
        const encoder = new TextEncoder();
        const decoder = new TextDecoder();
        const encoded = encoder.encode(str);
        return encoded.byteLength > size
            ? '...truncated...' + decoder.decode(encoded.slice(-size))
            : str;
    };
    getAppCommand = () => this.packageManagerController.getCommand([
        'tsx',
        this.backendLocator.locate(),
    ]);
    invokeTsc = async (deployProps) => {
        if (!deployProps?.validateAppSources) {
            return;
        }
        try {
            await this.executeCommand([
                'tsc',
                '--showConfig',
                '--project',
                dirname(this.backendLocator.locate()),
            ], { redirectStdoutToStderr: true } // TSC prints errors to stdout by default
            );
        }
        catch (error) {
            // If we cannot load ts config, turn off type checking
            return;
        }
        try {
            await this.executeCommand([
                'tsc',
                '--noEmit',
                '--skipLibCheck',
                // pointing the project arg to the amplify backend directory will use the tsconfig present in that directory
                '--project',
                dirname(this.backendLocator.locate()),
            ], { redirectStdoutToStderr: true } // TSC prints errors to stdout by default
            );
        }
        catch (err) {
            throw new AmplifyUserError('SyntaxError', {
                message: 'TypeScript validation check failed.',
                resolution: 'Fix the syntax and type errors in your backend definition.',
            }, err instanceof Error ? err : undefined);
        }
    };
    /**
     * calls invokeCDK and wrap it in a try catch
     */
    tryInvokeCdk = async (invokableCommand, backendId, appArgument, additionalArguments) => {
        try {
            return await this.invokeCdk(invokableCommand, backendId, appArgument, additionalArguments);
        }
        catch (err) {
            throw this.cdkErrorMapper.getAmplifyError(err);
        }
    };
    /**
     * Executes a CDK command
     */
    invokeCdk = async (invokableCommand, backendId, appArgument, additionalArguments) => {
        // Basic args
        const cdkCommandArgs = [
            'cdk',
            invokableCommand.toString(),
            // This is unfortunate. CDK writes everything to stderr without `--ci` flag and we need to differentiate between the two.
            // See https://github.com/aws/aws-cdk/issues/7717 for more details.
            '--ci',
            '--app',
            appArgument,
            '--all',
            '--output',
            this.relativeCloudAssemblyLocation,
        ];
        // Add context information if available
        cdkCommandArgs.push('--context', `${CDKContextKey.BACKEND_NAMESPACE}=${backendId.namespace}`, '--context', `${CDKContextKey.BACKEND_NAME}=${backendId.name}`);
        if (backendId.type !== 'sandbox') {
            cdkCommandArgs.push('--require-approval', 'never');
        }
        cdkCommandArgs.push('--context', `${CDKContextKey.DEPLOYMENT_TYPE}=${backendId.type}`);
        if (additionalArguments) {
            cdkCommandArgs.push(...additionalArguments);
        }
        return await this.executeCommand(cdkCommandArgs);
    };
    populateCDKOutputFromStdout = async (output, stdout) => {
        const regexTotalTime = /✨ {2}Total time: (\d*\.*\d*)s.*/;
        const regexSynthTime = /✨ {2}Synthesis time: (\d*\.*\d*)s/;
        const reader = readline.createInterface(stdout);
        for await (const line of reader) {
            if (line.includes('✨')) {
                // Good chance that it contains timing information
                const totalTime = line.match(regexTotalTime);
                if (totalTime && totalTime.length > 1 && !isNaN(+totalTime[1])) {
                    output.deploymentTimes.totalTime = +totalTime[1];
                }
                const synthTime = line.match(regexSynthTime);
                if (synthTime && synthTime.length > 1 && !isNaN(+synthTime[1])) {
                    output.deploymentTimes.synthesisTime = +synthTime[1];
                }
            }
        }
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2RrX2RlcGxveWVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2Nka19kZXBsb3llci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLE1BQU0sTUFBTSxRQUFRLENBQUM7QUFDNUIsT0FBTyxRQUFRLE1BQU0sVUFBVSxDQUFDO0FBYWhDLE9BQU8sRUFDTCxZQUFZLEVBQ1osZ0JBQWdCLEVBRWhCLGFBQWEsR0FDZCxNQUFNLDRCQUE0QixDQUFDO0FBQ3BDLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFFL0I7O0dBRUc7QUFDSCxJQUFLLGdCQUlKO0FBSkQsV0FBSyxnQkFBZ0I7SUFDbkIscUNBQWlCLENBQUE7SUFDakIsdUNBQW1CLENBQUE7SUFDbkIsbUNBQWUsQ0FBQTtBQUNqQixDQUFDLEVBSkksZ0JBQWdCLEtBQWhCLGdCQUFnQixRQUlwQjtBQUVEOztHQUVHO0FBQ0gsTUFBTSxPQUFPLFdBQVc7SUFNSDtJQUNBO0lBQ0E7SUFQRiw2QkFBNkIsR0FBRyw0QkFBNEIsQ0FBQztJQUM5RTs7T0FFRztJQUNILFlBQ21CLGNBQThCLEVBQzlCLGNBQThCLEVBQzlCLHdCQUFrRDtRQUZsRCxtQkFBYyxHQUFkLGNBQWMsQ0FBZ0I7UUFDOUIsbUJBQWMsR0FBZCxjQUFjLENBQWdCO1FBQzlCLDZCQUF3QixHQUF4Qix3QkFBd0IsQ0FBMEI7SUFDbEUsQ0FBQztJQUNKOztPQUVHO0lBQ0gsTUFBTSxHQUFHLEtBQUssRUFBRSxTQUE0QixFQUFFLFdBQXlCLEVBQUUsRUFBRTtRQUN6RSxNQUFNLGNBQWMsR0FBYSxFQUFFLENBQUM7UUFDcEMsSUFBSSxTQUFTLENBQUMsSUFBSSxLQUFLLFNBQVMsRUFBRTtZQUNoQyxjQUFjLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUM7WUFDMUMsY0FBYyxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1lBQ3ZDLElBQUksV0FBVyxFQUFFLGlCQUFpQixF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TSxHQUFHLFFBQVEsQ0FBQyxlQUFlLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDaEQsSUFBSSxLQUFLLEVBQUUsTUFBTSxJQUFJLElBQUksTUFBTSxFQUFFO1lBQy9CLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsRUFBRTtnQkFDdEIsa0RBQWtEO2dCQUNsRCxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLGNBQWMsQ0FBQyxDQUFDO2dCQUM3QyxJQUFJLFNBQVMsSUFBSSxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO29CQUM5RCxNQUFNLENBQUMsZUFBZSxDQUFDLFNBQVMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztpQkFDbEQ7Z0JBQ0QsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxjQUFjLENBQUMsQ0FBQztnQkFDN0MsSUFBSSxTQUFTLElBQUksU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtvQkFDOUQsTUFBTSxDQUFDLGVBQWUsQ0FBQyxhQUFhLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7aUJBQ3REO2FBQ0Y7U0FDRjtJQUNILENBQUMsQ0FBQztDQUNIIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHN0cmVhbSBmcm9tICdzdHJlYW0nO1xuaW1wb3J0IHJlYWRsaW5lIGZyb20gJ3JlYWRsaW5lJztcbmltcG9ydCB7XG4gIEJhY2tlbmREZXBsb3llcixcbiAgRGVwbG95UHJvcHMsXG4gIERlcGxveVJlc3VsdCxcbiAgRGVzdHJveVByb3BzLFxuICBEZXN0cm95UmVzdWx0LFxufSBmcm9tICcuL2Nka19kZXBsb3llcl9zaW5nbGV0b25fZmFjdG9yeS5qcyc7XG5pbXBvcnQgeyBDREtEZXBsb3ltZW50RXJyb3IsIENka0Vycm9yTWFwcGVyIH0gZnJvbSAnLi9jZGtfZXJyb3JfbWFwcGVyLmpzJztcbmltcG9ydCB7XG4gIEJhY2tlbmRJZGVudGlmaWVyLFxuICB0eXBlIFBhY2thZ2VNYW5hZ2VyQ29udHJvbGxlcixcbn0gZnJvbSAnQGF3cy1hbXBsaWZ5L3BsdWdpbi10eXBlcyc7XG5pbXBvcnQge1xuICBBbXBsaWZ5RXJyb3IsXG4gIEFtcGxpZnlVc2VyRXJyb3IsXG4gIEJhY2tlbmRMb2NhdG9yLFxuICBDREtDb250ZXh0S2V5LFxufSBmcm9tICdAYXdzLWFtcGxpZnkvcGxhdGZvcm0tY29yZSc7XG5pbXBvcnQgeyBkaXJuYW1lIH0gZnJvbSAncGF0aCc7XG5cbi8qKlxuICogQ29tbWFuZHMgdGhhdCBjYW4gYmUgaW52b2tlZFxuICovXG5lbnVtIEludm9rYWJsZUNvbW1hbmQge1xuICBERVBMT1kgPSAnZGVwbG95JyxcbiAgREVTVFJPWSA9ICdkZXN0cm95JyxcbiAgU1lOVEggPSAnc3ludGgnLFxufVxuXG4vKipcbiAqIEludm9rZXMgQ0RLIGNvbW1hbmQgdmlhIGV4ZWNhXG4gKi9cbmV4cG9ydCBjbGFzcyBDREtEZXBsb3llciBpbXBsZW1lbnRzIEJhY2tlbmREZXBsb3llciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgcmVsYXRpdmVDbG91ZEFzc2VtYmx5TG9jYXRpb24gPSAnLmFtcGxpZnkvYXJ0aWZhY3RzL2Nkay5vdXQnO1xuICAvKipcbiAgICogSW5zdGFudGlhdGVzIGluc3RhbmNlIG9mIENES0RlcGxveWVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNka0Vycm9yTWFwcGVyOiBDZGtFcnJvck1hcHBlcixcbiAgICBwcml2YXRlIHJlYWRvbmx5IGJhY2tlbmRMb2NhdG9yOiBCYWNrZW5kTG9jYXRvcixcbiAgICBwcml2YXRlIHJlYWRvbmx5IHBhY2thZ2VNYW5hZ2VyQ29udHJvbGxlcjogUGFja2FnZU1hbmFnZXJDb250cm9sbGVyXG4gICkge31cbiAgLyoqXG4gICAqIEludm9rZXMgY2RrIGRlcGxveSBjb21tYW5kXG4gICAqL1xuICBkZXBsb3kgPSBhc3luYyAoYmFja2VuZElkOiBCYWNrZW5kSWRlbnRpZmllciwgZGVwbG95UHJvcHM/OiBEZXBsb3lQcm9wcykgPT4ge1xuICAgIGNvbnN0IGNka0NvbW1hbmRBcmdzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGlmIChiYWNrZW5kSWQudHlwZSA9PT0gJ3NhbmRib3gnKSB7XG4gICAgICBjZGtDb21tYW5kQXJncy5wdXNoKCctLWhvdHN3YXAtZmFsbGJhY2snKTtcbiAgICAgIGNka0NvbW1hbmRBcmdzLnB1c2goJy0tbWV0aG9kPWRpcmVjdCcpO1xuICAgICAgaWYgKGRlcGxveVByb3BzPy5zZWNyZXRMYXN0VXBkYXRlZCkge1xuICAgICAgICBjZGtDb21tYW5kQXJncy5wdXNoKFxuICAgICAgICAgICctLWNvbnRleHQnLFxuICAgICAgICAgIGBzZWNyZXRMYXN0VXBkYXRlZD0ke2RlcGxveVByb3BzLnNlY3JldExhc3RVcGRhdGVkLmdldFRpbWUoKX1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRlcGxveVByb3BzPy5wcm9maWxlKSB7XG4gICAgICBjZGtDb21tYW5kQXJncy5wdXNoKCctLXByb2ZpbGUnLCBkZXBsb3lQcm9wcy5wcm9maWxlKTtcbiAgICB9XG5cbiAgICAvLyBmaXJzdCBzeW50aCB3aXRoIHRoZSBiYWNrZW5kIGRlZmluaXRpb24gYnV0IHN1cHByZXNzIGFueSBlcnJvcnMuXG4gICAgLy8gV2Ugd2FudCB0byBzaG93IGVycm9ycyBmcm9tIHRoZSBUUyBjb21waWxlciByYXRoZXIgdGhhbiB0aGUgRVNCdWlsZCBhc1xuICAgIC8vIFRTIGVycm9ycyBhcmUgbW9yZSByZWxldmFudCAoTGlicmFyeSB2YWxpZGF0aW9ucyBhcmUgdHlwZSByZWxpYW50KS5cbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGxldCBzeW50aEVycm9yID0gdW5kZWZpbmVkO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLnRyeUludm9rZUNkayhcbiAgICAgICAgSW52b2thYmxlQ29tbWFuZC5TWU5USCxcbiAgICAgICAgYmFja2VuZElkLFxuICAgICAgICB0aGlzLmdldEFwcENvbW1hbmQoKSxcbiAgICAgICAgY2RrQ29tbWFuZEFyZ3MuY29uY2F0KCctLXF1aWV0JykgLy8gZG9uJ3QgcHJpbnQgdGhlIENGTiB0ZW1wbGF0ZSB0byBzdGRvdXRcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgc3ludGhFcnJvciA9IGU7XG4gICAgfVxuICAgIC8vIENESyBwcmludHMgc3ludGggdGltZSBpbiBzZWNvbmRzIHJvdW5kZWQgdG8gMiBkZWNpbWFsIHBsYWNlcy4gSGVyZSB3ZSBkdXBsaWNhdGUgdGhhdCBiZWhhdmlvci5cbiAgICBjb25zdCBzeW50aFRpbWVTZWNvbmRzID0gTWF0aC5mbG9vcigoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSkgLyAxMCkgLyAxMDA7XG5cbiAgICAvLyB0aGVuIHJ1biB0eXBlIGNoZWNrc1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmludm9rZVRzYyhkZXBsb3lQcm9wcyk7XG4gICAgfSBjYXRjaCAodHlwZUVycm9yOiB1bmtub3duKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHN5bnRoRXJyb3IgJiZcbiAgICAgICAgQW1wbGlmeUVycm9yLmlzQW1wbGlmeUVycm9yKHR5cGVFcnJvcikgJiZcbiAgICAgICAgdHlwZUVycm9yLmNhdXNlPy5tZXNzYWdlLm1hdGNoKFxuICAgICAgICAgIC9DYW5ub3QgZmluZCBtb2R1bGUgJ1xcJGFtcGxpZnlcXC9lbnZcXC8uKicgb3IgaXRzIGNvcnJlc3BvbmRpbmcgdHlwZSBkZWNsYXJhdGlvbnMvXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICAvLyBzeW50aCBoYXMgZmFpbGVkIGFuZCB3ZSBkb24ndCBoYXZlIGF1dG8gZ2VuZXJhdGVkIGZ1bmN0aW9uIGVudmlyb25tZW50IGRlZmluaXRpb24gZmlsZXMuIFRoaXNcbiAgICAgICAgLy8gcmVzdWx0ZWQgaW4gdGhlIGV4Y2VwdGlvbiBjYXVnaHQgaGVyZSwgd2hpY2ggaXMgbm90IHZlcnkgdXNlZnVsIGZvciB0aGUgY3VzdG9tZXJzLlxuICAgICAgICAvLyBXZSBpbnN0ZWFkIHRocm93IHRoZSBzeW50aCBlcnJvciBmb3IgY3VzdG9tZXJzIHRvIGZpeCB3aGF0IGNhdXNlZCB0aGUgc3ludGggdG8gZmFpbC5cbiAgICAgICAgdGhyb3cgc3ludGhFcnJvcjtcbiAgICAgIH1cbiAgICAgIHRocm93IHR5cGVFcnJvcjtcbiAgICB9XG5cbiAgICAvLyBJZiBzb21laG93IFRTQyB3YXMgc3VjY2Vzc2Z1bCBidXQgc3ludGggd2Fzbid0LCB3ZSBub3cgdGhyb3cgdG8gc3VyZmFjZSB0aGUgc3ludGggZXJyb3JcbiAgICBpZiAoc3ludGhFcnJvcikge1xuICAgICAgdGhyb3cgc3ludGhFcnJvcjtcbiAgICB9XG5cbiAgICAvLyB0aGVuIGRlcGxveSB3aXRoIHRoZSBjbG91ZCBhc3NlbWJseSB0aGF0IHdhcyBnZW5lcmF0ZWQgZHVyaW5nIHN5bnRoXG4gICAgY29uc3QgZGVwbG95UmVzdWx0ID0gYXdhaXQgdGhpcy50cnlJbnZva2VDZGsoXG4gICAgICBJbnZva2FibGVDb21tYW5kLkRFUExPWSxcbiAgICAgIGJhY2tlbmRJZCxcbiAgICAgIHRoaXMucmVsYXRpdmVDbG91ZEFzc2VtYmx5TG9jYXRpb24sXG4gICAgICBjZGtDb21tYW5kQXJnc1xuICAgICk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGVwbG95bWVudFRpbWVzOiB7XG4gICAgICAgIHN5bnRoZXNpc1RpbWU6IHN5bnRoVGltZVNlY29uZHMsXG4gICAgICAgIHRvdGFsVGltZTpcbiAgICAgICAgICBzeW50aFRpbWVTZWNvbmRzICsgKGRlcGxveVJlc3VsdD8uZGVwbG95bWVudFRpbWVzPy50b3RhbFRpbWUgfHwgMCksXG4gICAgICB9LFxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEludm9rZXMgY2RrIGRlc3Ryb3kgY29tbWFuZFxuICAgKi9cbiAgZGVzdHJveSA9IGFzeW5jIChcbiAgICBiYWNrZW5kSWQ6IEJhY2tlbmRJZGVudGlmaWVyLFxuICAgIGRlc3Ryb3lQcm9wcz86IERlc3Ryb3lQcm9wc1xuICApID0+IHtcbiAgICBjb25zdCBjZGtDb21tYW5kQXJnczogc3RyaW5nW10gPSBbJy0tZm9yY2UnXTtcbiAgICBpZiAoZGVzdHJveVByb3BzPy5wcm9maWxlKSB7XG4gICAgICBjZGtDb21tYW5kQXJncy5wdXNoKCctLXByb2ZpbGUnLCBkZXN0cm95UHJvcHMucHJvZmlsZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRyeUludm9rZUNkayhcbiAgICAgIEludm9rYWJsZUNvbW1hbmQuREVTVFJPWSxcbiAgICAgIGJhY2tlbmRJZCxcbiAgICAgIHRoaXMuZ2V0QXBwQ29tbWFuZCgpLFxuICAgICAgY2RrQ29tbWFuZEFyZ3NcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXcmFwcGVyIGZvciB0aGUgY2hpbGQgcHJvY2VzcyBleGVjdXRvci4gSGVscHMgaW4gdW5pdCB0ZXN0aW5nIGFzIG5vZGU6dGVzdCBmcmFtZXdvcmtcbiAgICogZG9lc24ndCBoYXZlIGNhcGFiaWxpdGllcyB0byBtb2NrIGV4cG9ydGVkIGZ1bmN0aW9ucyBsaWtlIGBleGVjYWAgYXMgb2YgcmlnaHQgbm93LlxuICAgKi9cbiAgZXhlY3V0ZUNvbW1hbmQgPSBhc3luYyAoXG4gICAgY29tbWFuZEFyZ3M6IHN0cmluZ1tdLFxuICAgIG9wdGlvbnM6IHsgcmVkaXJlY3RTdGRvdXRUb1N0ZGVycjogYm9vbGVhbiB9ID0ge1xuICAgICAgcmVkaXJlY3RTdGRvdXRUb1N0ZGVycjogZmFsc2UsXG4gICAgfVxuICApID0+IHtcbiAgICAvLyBXZSBsZXQgdGhlIHN0ZG91dCBhbmQgc3RkaW4gaW5oZXJpdCBhbmQgc3RyZWFtZWQgdG8gcGFyZW50IHByb2Nlc3MgYnV0IHBpcGVcbiAgICAvLyB0aGUgc3RkZXJyIGFuZCB1c2UgaXQgdG8gdGhyb3cgb24gZmFpbHVyZS4gVGhpcyBpcyB0byBwcmV2ZW50IGFjdHVhbFxuICAgIC8vIGFjdGlvbmFibGUgZXJyb3JzIGJlaW5nIGhpZGRlbiBhbW9uZyB0aGUgc3Rkb3V0LiBNb3Jlb3ZlciBleGVjYSBlcnJvcnMgYXJlXG4gICAgLy8gdXNlbGVzcyB3aGVuIGNhbGxpbmcgQ0xJcyB1bmxlc3MgeW91IG1hZGUgZXhlY2EgY2FsbGluZyBlcnJvci5cbiAgICBsZXQgYWdncmVnYXRlZFN0ZGVyciA9ICcnO1xuICAgIGNvbnN0IGFnZ3JlZ2F0b3JTdGRlcnJTdHJlYW0gPSBuZXcgc3RyZWFtLldyaXRhYmxlKCk7XG4gICAgYWdncmVnYXRvclN0ZGVyclN0cmVhbS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBkb25lKSB7XG4gICAgICBhZ2dyZWdhdGVkU3RkZXJyICs9IGNodW5rO1xuICAgICAgZG9uZSgpO1xuICAgIH07XG4gICAgY29uc3QgY2hpbGRQcm9jZXNzID0gdGhpcy5wYWNrYWdlTWFuYWdlckNvbnRyb2xsZXIucnVuV2l0aFBhY2thZ2VNYW5hZ2VyKFxuICAgICAgY29tbWFuZEFyZ3MsXG4gICAgICBwcm9jZXNzLmN3ZCgpLFxuICAgICAge1xuICAgICAgICBzdGRpbjogJ2luaGVyaXQnLFxuICAgICAgICBzdGRvdXQ6ICdwaXBlJyxcbiAgICAgICAgc3RkZXJyOiAncGlwZScsXG4gICAgICAgIC8vIFBpcGluZyB0aGUgb3V0cHV0IGJ5IGRlZmF1bHQgc3RyaXBzIG9mZiB0aGUgY29sb3IuIFRoaXMgaXMgYSB3b3JrYXJvdW5kIHRvXG4gICAgICAgIC8vIHByZXNlcnZlIHRoZSBjb2xvciBiZWluZyBwaXBlZCB0byBwYXJlbnQgcHJvY2Vzcy5cbiAgICAgICAgZXh0ZW5kRW52OiB0cnVlLFxuICAgICAgICBlbnY6IHsgRk9SQ0VfQ09MT1I6ICcxJyB9LFxuICAgICAgfVxuICAgICk7XG5cbiAgICBjaGlsZFByb2Nlc3Muc3RkZXJyPy5waXBlKGFnZ3JlZ2F0b3JTdGRlcnJTdHJlYW0pO1xuXG4gICAgaWYgKG9wdGlvbnM/LnJlZGlyZWN0U3Rkb3V0VG9TdGRlcnIpIHtcbiAgICAgIGNoaWxkUHJvY2Vzcy5zdGRvdXQ/LnBpcGUoYWdncmVnYXRvclN0ZGVyclN0cmVhbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoaWxkUHJvY2Vzcy5zdGRvdXQ/LnBpcGUocHJvY2Vzcy5zdGRvdXQpO1xuICAgIH1cblxuICAgIGNvbnN0IGNka091dHB1dCA9IHsgZGVwbG95bWVudFRpbWVzOiB7fSB9O1xuICAgIGlmIChjaGlsZFByb2Nlc3Muc3Rkb3V0KSB7XG4gICAgICBhd2FpdCB0aGlzLnBvcHVsYXRlQ0RLT3V0cHV0RnJvbVN0ZG91dChjZGtPdXRwdXQsIGNoaWxkUHJvY2Vzcy5zdGRvdXQpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBjaGlsZFByb2Nlc3M7XG4gICAgICByZXR1cm4gY2RrT3V0cHV0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBzd2FsbG93IGV4ZWNhIGVycm9yIGlmIHRoZSBjZGsgY2xpIHJhbiBhbmQgcHJvZHVjZWQgc29tZSBzdGRlcnIuXG4gICAgICAvLyBNb3N0IG9mIHRoZSB0aW1lIHRoaXMgZXJyb3IgaXMgbm9pc2UoYmFzaWNhbGx5IGNoaWxkIGV4aXRlZCB3aXRoIGV4aXQgY29kZS4uLilcbiAgICAgIC8vIGJ1YmJsaW5nIHRoaXMgdXAgdG8gY3VzdG9tZXJzIGFkZCBjb25mdXNpb24gKEN1c3RvbWVycyBkb24ndCBuZWVkIHRvIGtub3cgd2UgYXJlIHJ1bm5pbmcgSVBDIGNhbGxzXG4gICAgICAvLyBhbmQgdGhlaXIgZXhpdCBjb2RlcyBwcmludGVkIHdoaWxlIHNhbmRib3ggY29udGludWUgdG8gcnVuKS4gSGVuY2Ugd2UgZXhwbGljaXRseSBkb24ndCBwYXNzIGVycm9yIGluIHRoZSBjYXVzZVxuICAgICAgLy8gcmF0aGVyIHRocm93IHRoZSBlbnRpcmUgc3RkZXJyIGZvciBjbGllbnRzIHRvIGZpZ3VyZSBvdXQgd2hhdCB0byBkbyB3aXRoIGl0LlxuICAgICAgLy8gSG93ZXZlciBpZiB0aGUgY2RrIHByb2Nlc3MgZGlkbid0IHJ1biBvciBwcm9kdWNlZCBubyBvdXRwdXQsIHRoZW4gd2UgaGF2ZSBub3RoaW5nIHRvIGdvIG9uIHdpdGguIFNvIHdlIHRocm93XG4gICAgICAvLyB0aGlzIGVycm9yIHRvIGFpZCBpbiBzb21lIGRlYnVnZ2luZy5cbiAgICAgIGlmIChhZ2dyZWdhdGVkU3RkZXJyLnRyaW0oKSkge1xuICAgICAgICAvLyBJZiB0aGUgc3RyaW5nIGlzIG1vcmUgdGhhbiA2NUtCLCB0cnVuY2F0ZSBhbmQga2VlcCB0aGUgbGFzdCBwb3J0aW9uLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYW1wbGlmeS1iYWNrZW5kLXJ1bGVzL3ByZWZlci1hbXBsaWZ5LWVycm9yc1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy50cnVuY2F0ZVN0cmluZyhhZ2dyZWdhdGVkU3RkZXJyLCA2NTAwMCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgdHJ1bmNhdGVTdHJpbmcgPSAoc3RyOiBzdHJpbmcsIHNpemU6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgY29uc3QgZW5jb2RlZCA9IGVuY29kZXIuZW5jb2RlKHN0cik7XG4gICAgcmV0dXJuIGVuY29kZWQuYnl0ZUxlbmd0aCA+IHNpemVcbiAgICAgID8gJy4uLnRydW5jYXRlZC4uLicgKyBkZWNvZGVyLmRlY29kZShlbmNvZGVkLnNsaWNlKC1zaXplKSlcbiAgICAgIDogc3RyO1xuICB9O1xuXG4gIHByaXZhdGUgZ2V0QXBwQ29tbWFuZCA9ICgpID0+XG4gICAgdGhpcy5wYWNrYWdlTWFuYWdlckNvbnRyb2xsZXIuZ2V0Q29tbWFuZChbXG4gICAgICAndHN4JyxcbiAgICAgIHRoaXMuYmFja2VuZExvY2F0b3IubG9jYXRlKCksXG4gICAgXSk7XG5cbiAgcHJpdmF0ZSBpbnZva2VUc2MgPSBhc3luYyAoZGVwbG95UHJvcHM/OiBEZXBsb3lQcm9wcykgPT4ge1xuICAgIGlmICghZGVwbG95UHJvcHM/LnZhbGlkYXRlQXBwU291cmNlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5leGVjdXRlQ29tbWFuZChcbiAgICAgICAgW1xuICAgICAgICAgICd0c2MnLFxuICAgICAgICAgICctLXNob3dDb25maWcnLFxuICAgICAgICAgICctLXByb2plY3QnLFxuICAgICAgICAgIGRpcm5hbWUodGhpcy5iYWNrZW5kTG9jYXRvci5sb2NhdGUoKSksXG4gICAgICAgIF0sXG4gICAgICAgIHsgcmVkaXJlY3RTdGRvdXRUb1N0ZGVycjogdHJ1ZSB9IC8vIFRTQyBwcmludHMgZXJyb3JzIHRvIHN0ZG91dCBieSBkZWZhdWx0XG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBJZiB3ZSBjYW5ub3QgbG9hZCB0cyBjb25maWcsIHR1cm4gb2ZmIHR5cGUgY2hlY2tpbmdcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuZXhlY3V0ZUNvbW1hbmQoXG4gICAgICAgIFtcbiAgICAgICAgICAndHNjJyxcbiAgICAgICAgICAnLS1ub0VtaXQnLFxuICAgICAgICAgICctLXNraXBMaWJDaGVjaycsXG4gICAgICAgICAgLy8gcG9pbnRpbmcgdGhlIHByb2plY3QgYXJnIHRvIHRoZSBhbXBsaWZ5IGJhY2tlbmQgZGlyZWN0b3J5IHdpbGwgdXNlIHRoZSB0c2NvbmZpZyBwcmVzZW50IGluIHRoYXQgZGlyZWN0b3J5XG4gICAgICAgICAgJy0tcHJvamVjdCcsXG4gICAgICAgICAgZGlybmFtZSh0aGlzLmJhY2tlbmRMb2NhdG9yLmxvY2F0ZSgpKSxcbiAgICAgICAgXSxcbiAgICAgICAgeyByZWRpcmVjdFN0ZG91dFRvU3RkZXJyOiB0cnVlIH0gLy8gVFNDIHByaW50cyBlcnJvcnMgdG8gc3Rkb3V0IGJ5IGRlZmF1bHRcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgQW1wbGlmeVVzZXJFcnJvcjxDREtEZXBsb3ltZW50RXJyb3I+KFxuICAgICAgICAnU3ludGF4RXJyb3InLFxuICAgICAgICB7XG4gICAgICAgICAgbWVzc2FnZTogJ1R5cGVTY3JpcHQgdmFsaWRhdGlvbiBjaGVjayBmYWlsZWQuJyxcbiAgICAgICAgICByZXNvbHV0aW9uOlxuICAgICAgICAgICAgJ0ZpeCB0aGUgc3ludGF4IGFuZCB0eXBlIGVycm9ycyBpbiB5b3VyIGJhY2tlbmQgZGVmaW5pdGlvbi4nLFxuICAgICAgICB9LFxuICAgICAgICBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyciA6IHVuZGVmaW5lZFxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIGNhbGxzIGludm9rZUNESyBhbmQgd3JhcCBpdCBpbiBhIHRyeSBjYXRjaFxuICAgKi9cbiAgcHJpdmF0ZSB0cnlJbnZva2VDZGsgPSBhc3luYyAoXG4gICAgaW52b2thYmxlQ29tbWFuZDogSW52b2thYmxlQ29tbWFuZCxcbiAgICBiYWNrZW5kSWQ6IEJhY2tlbmRJZGVudGlmaWVyLFxuICAgIGFwcEFyZ3VtZW50OiBzdHJpbmcsXG4gICAgYWRkaXRpb25hbEFyZ3VtZW50cz86IHN0cmluZ1tdXG4gICk6IFByb21pc2U8RGVwbG95UmVzdWx0IHwgRGVzdHJveVJlc3VsdD4gPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5pbnZva2VDZGsoXG4gICAgICAgIGludm9rYWJsZUNvbW1hbmQsXG4gICAgICAgIGJhY2tlbmRJZCxcbiAgICAgICAgYXBwQXJndW1lbnQsXG4gICAgICAgIGFkZGl0aW9uYWxBcmd1bWVudHNcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyB0aGlzLmNka0Vycm9yTWFwcGVyLmdldEFtcGxpZnlFcnJvcihlcnIgYXMgRXJyb3IpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRXhlY3V0ZXMgYSBDREsgY29tbWFuZFxuICAgKi9cbiAgcHJpdmF0ZSBpbnZva2VDZGsgPSBhc3luYyAoXG4gICAgaW52b2thYmxlQ29tbWFuZDogSW52b2thYmxlQ29tbWFuZCxcbiAgICBiYWNrZW5kSWQ6IEJhY2tlbmRJZGVudGlmaWVyLFxuICAgIGFwcEFyZ3VtZW50OiBzdHJpbmcsXG4gICAgYWRkaXRpb25hbEFyZ3VtZW50cz86IHN0cmluZ1tdXG4gICk6IFByb21pc2U8RGVwbG95UmVzdWx0IHwgRGVzdHJveVJlc3VsdD4gPT4ge1xuICAgIC8vIEJhc2ljIGFyZ3NcbiAgICBjb25zdCBjZGtDb21tYW5kQXJncyA9IFtcbiAgICAgICdjZGsnLFxuICAgICAgaW52b2thYmxlQ29tbWFuZC50b1N0cmluZygpLFxuICAgICAgLy8gVGhpcyBpcyB1bmZvcnR1bmF0ZS4gQ0RLIHdyaXRlcyBldmVyeXRoaW5nIHRvIHN0ZGVyciB3aXRob3V0IGAtLWNpYCBmbGFnIGFuZCB3ZSBuZWVkIHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlbiB0aGUgdHdvLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLWNkay9pc3N1ZXMvNzcxNyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgJy0tY2knLFxuICAgICAgJy0tYXBwJyxcbiAgICAgIGFwcEFyZ3VtZW50LFxuICAgICAgJy0tYWxsJyxcbiAgICAgICctLW91dHB1dCcsXG4gICAgICB0aGlzLnJlbGF0aXZlQ2xvdWRBc3NlbWJseUxvY2F0aW9uLFxuICAgIF07XG5cbiAgICAvLyBBZGQgY29udGV4dCBpbmZvcm1hdGlvbiBpZiBhdmFpbGFibGVcbiAgICBjZGtDb21tYW5kQXJncy5wdXNoKFxuICAgICAgJy0tY29udGV4dCcsXG4gICAgICBgJHtDREtDb250ZXh0S2V5LkJBQ0tFTkRfTkFNRVNQQUNFfT0ke2JhY2tlbmRJZC5uYW1lc3BhY2V9YCxcbiAgICAgICctLWNvbnRleHQnLFxuICAgICAgYCR7Q0RLQ29udGV4dEtleS5CQUNLRU5EX05BTUV9PSR7YmFja2VuZElkLm5hbWV9YFxuICAgICk7XG5cbiAgICBpZiAoYmFja2VuZElkLnR5cGUgIT09ICdzYW5kYm94Jykge1xuICAgICAgY2RrQ29tbWFuZEFyZ3MucHVzaCgnLS1yZXF1aXJlLWFwcHJvdmFsJywgJ25ldmVyJyk7XG4gICAgfVxuXG4gICAgY2RrQ29tbWFuZEFyZ3MucHVzaChcbiAgICAgICctLWNvbnRleHQnLFxuICAgICAgYCR7Q0RLQ29udGV4dEtleS5ERVBMT1lNRU5UX1RZUEV9PSR7YmFja2VuZElkLnR5cGV9YFxuICAgICk7XG5cbiAgICBpZiAoYWRkaXRpb25hbEFyZ3VtZW50cykge1xuICAgICAgY2RrQ29tbWFuZEFyZ3MucHVzaCguLi5hZGRpdGlvbmFsQXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5leGVjdXRlQ29tbWFuZChjZGtDb21tYW5kQXJncyk7XG4gIH07XG5cbiAgcHJpdmF0ZSBwb3B1bGF0ZUNES091dHB1dEZyb21TdGRvdXQgPSBhc3luYyAoXG4gICAgb3V0cHV0OiBEZXBsb3lSZXN1bHQgfCBEZXN0cm95UmVzdWx0LFxuICAgIHN0ZG91dDogc3RyZWFtLlJlYWRhYmxlXG4gICkgPT4ge1xuICAgIGNvbnN0IHJlZ2V4VG90YWxUaW1lID0gL+KcqCB7Mn1Ub3RhbCB0aW1lOiAoXFxkKlxcLipcXGQqKXMuKi87XG4gICAgY29uc3QgcmVnZXhTeW50aFRpbWUgPSAv4pyoIHsyfVN5bnRoZXNpcyB0aW1lOiAoXFxkKlxcLipcXGQqKXMvO1xuICAgIGNvbnN0IHJlYWRlciA9IHJlYWRsaW5lLmNyZWF0ZUludGVyZmFjZShzdGRvdXQpO1xuICAgIGZvciBhd2FpdCAoY29uc3QgbGluZSBvZiByZWFkZXIpIHtcbiAgICAgIGlmIChsaW5lLmluY2x1ZGVzKCfinKgnKSkge1xuICAgICAgICAvLyBHb29kIGNoYW5jZSB0aGF0IGl0IGNvbnRhaW5zIHRpbWluZyBpbmZvcm1hdGlvblxuICAgICAgICBjb25zdCB0b3RhbFRpbWUgPSBsaW5lLm1hdGNoKHJlZ2V4VG90YWxUaW1lKTtcbiAgICAgICAgaWYgKHRvdGFsVGltZSAmJiB0b3RhbFRpbWUubGVuZ3RoID4gMSAmJiAhaXNOYU4oK3RvdGFsVGltZVsxXSkpIHtcbiAgICAgICAgICBvdXRwdXQuZGVwbG95bWVudFRpbWVzLnRvdGFsVGltZSA9ICt0b3RhbFRpbWVbMV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3ludGhUaW1lID0gbGluZS5tYXRjaChyZWdleFN5bnRoVGltZSk7XG4gICAgICAgIGlmIChzeW50aFRpbWUgJiYgc3ludGhUaW1lLmxlbmd0aCA+IDEgJiYgIWlzTmFOKCtzeW50aFRpbWVbMV0pKSB7XG4gICAgICAgICAgb3V0cHV0LmRlcGxveW1lbnRUaW1lcy5zeW50aGVzaXNUaW1lID0gK3N5bnRoVGltZVsxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbiJdfQ==