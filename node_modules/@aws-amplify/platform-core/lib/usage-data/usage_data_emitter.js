"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultUsageDataEmitter = void 0;
const uuid_1 = require("uuid");
const account_id_fetcher_js_1 = require("./account_id_fetcher.js");
const os_1 = __importDefault(require("os"));
const https_1 = __importDefault(require("https"));
const get_installation_id_js_1 = require("./get_installation_id.js");
const constants_js_1 = require("./constants.js");
const get_usage_data_url_js_1 = require("./get_usage_data_url.js");
const is_ci_1 = __importDefault(require("is-ci"));
const serializable_error_js_1 = require("./serializable_error.js");
/**
 * Entry point for sending usage data metrics
 */
class DefaultUsageDataEmitter {
    libraryVersion;
    sessionUuid;
    url;
    accountIdFetcher;
    /**
     * Constructor for UsageDataEmitter
     */
    constructor(libraryVersion, sessionUuid = (0, uuid_1.v4)(), url = (0, get_usage_data_url_js_1.getUrl)(), accountIdFetcher = new account_id_fetcher_js_1.AccountIdFetcher()) {
        this.libraryVersion = libraryVersion;
        this.sessionUuid = sessionUuid;
        this.url = url;
        this.accountIdFetcher = accountIdFetcher;
    }
    emitSuccess = async (metrics, dimensions) => {
        try {
            const data = await this.getUsageData({
                state: 'SUCCEEDED',
                metrics,
                dimensions,
            });
            await this.send(data);
            // eslint-disable-next-line amplify-backend-rules/no-empty-catch
        }
        catch {
            // Don't propagate errors related to not being able to send telemetry
        }
    };
    emitFailure = async (error, dimensions) => {
        try {
            const data = await this.getUsageData({
                state: 'FAILED',
                error,
                dimensions,
            });
            await this.send(data);
            // eslint-disable-next-line amplify-backend-rules/no-empty-catch
        }
        catch {
            // Don't propagate errors related to not being able to send telemetry
        }
    };
    getUsageData = async (options) => {
        return {
            accountId: await this.accountIdFetcher.fetch(),
            sessionUuid: this.sessionUuid,
            installationUuid: (0, get_installation_id_js_1.getInstallationUuid)(),
            amplifyCliVersion: this.libraryVersion,
            timestamp: new Date().toISOString(),
            error: options.error ? new serializable_error_js_1.SerializableError(options.error) : undefined,
            downstreamException: options.error &&
                options.error.cause &&
                options.error.cause instanceof Error
                ? new serializable_error_js_1.SerializableError(options.error.cause)
                : undefined,
            payloadVersion: constants_js_1.latestPayloadVersion,
            osPlatform: os_1.default.platform(),
            osRelease: os_1.default.release(),
            nodeVersion: process.versions.node,
            state: options.state,
            codePathDurations: this.translateMetricsToUsageData(options.metrics),
            input: this.translateDimensionsToUsageData(options.dimensions),
            isCi: is_ci_1.default,
            projectSetting: {
                editor: process.env.npm_config_user_agent,
            },
        };
    };
    send = (data) => {
        return new Promise((resolve) => {
            const payload = JSON.stringify(data);
            const req = https_1.default.request({
                hostname: this.url.hostname,
                port: this.url.port,
                path: this.url.path,
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    'content-length': payload.length,
                },
            });
            req.on('error', () => {
                /* noop */
            });
            req.setTimeout(2000, () => {
                // 2 seconds
                resolve();
            });
            req.write(payload);
            req.end(() => {
                resolve();
            });
        });
    };
    translateMetricsToUsageData = (metrics) => {
        if (!metrics)
            return {};
        let totalDuration, platformStartup;
        for (const [name, data] of Object.entries(metrics)) {
            if (name === 'totalTime') {
                totalDuration = Math.round(data);
            }
            else if (name === 'synthesisTime') {
                platformStartup = Math.round(data);
            }
        }
        return { totalDuration, platformStartup };
    };
    translateDimensionsToUsageData = (dimensions) => {
        let command = '';
        if (dimensions) {
            for (const [name, data] of Object.entries(dimensions)) {
                if (name === 'command') {
                    command = data;
                }
            }
        }
        return { command, plugin: 'Gen2' };
    };
}
exports.DefaultUsageDataEmitter = DefaultUsageDataEmitter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXNhZ2VfZGF0YV9lbWl0dGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3VzYWdlLWRhdGEvdXNhZ2VfZGF0YV9lbWl0dGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLCtCQUFrQztBQUNsQyxtRUFBMkQ7QUFFM0QsNENBQW9CO0FBQ3BCLGtEQUEwQjtBQUMxQixxRUFBK0Q7QUFDL0QsaURBQXNEO0FBQ3RELG1FQUFpRDtBQUNqRCxrREFBeUI7QUFDekIsbUVBQTREO0FBSTVEOztHQUVHO0FBQ0gsTUFBYSx1QkFBdUI7SUFLZjtJQUNBO0lBQ0E7SUFDQTtJQVBuQjs7T0FFRztJQUNILFlBQ21CLGNBQXNCLEVBQ3RCLGNBQWMsSUFBQSxTQUFJLEdBQUUsRUFDcEIsTUFBTSxJQUFBLDhCQUFNLEdBQUUsRUFDZCxtQkFBbUIsSUFBSSx3Q0FBZ0IsRUFBRTtRQUh6QyxtQkFBYyxHQUFkLGNBQWMsQ0FBUTtRQUN0QixnQkFBVyxHQUFYLFdBQVcsQ0FBUztRQUNwQixRQUFHLEdBQUgsR0FBRyxDQUFXO1FBQ2QscUJBQWdCLEdBQWhCLGdCQUFnQixDQUF5QjtJQUN6RCxDQUFDO0lBRUosV0FBVyxHQUFHLEtBQUssRUFDakIsT0FBZ0MsRUFDaEMsVUFBbUMsRUFDbkMsRUFBRTtRQUNGLElBQUk7WUFDRixNQUFNLElBQUksR0FBRyxNQUFNLElBQUksQ0FBQyxZQUFZLENBQUM7Z0JBQ25DLEtBQUssRUFBRSxXQUFXO2dCQUNsQixPQUFPO2dCQUNQLFVBQVU7YUFDWCxDQUFDLENBQUM7WUFDSCxNQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDdEIsZ0VBQWdFO1NBQ2pFO1FBQUMsTUFBTTtZQUNOLHFFQUFxRTtTQUN0RTtJQUNILENBQUMsQ0FBQztJQUVGLFdBQVcsR0FBRyxLQUFLLEVBQ2pCLEtBQW1CLEVBQ25CLFVBQW1DLEVBQ25DLEVBQUU7UUFDRixJQUFJO1lBQ0YsTUFBTSxJQUFJ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XG5pbXBvcnQgeyBBY2NvdW50SWRGZXRjaGVyIH0gZnJvbSAnLi9hY2NvdW50X2lkX2ZldGNoZXIuanMnO1xuaW1wb3J0IHsgVXNhZ2VEYXRhIH0gZnJvbSAnLi91c2FnZV9kYXRhLmpzJztcbmltcG9ydCBvcyBmcm9tICdvcyc7XG5pbXBvcnQgaHR0cHMgZnJvbSAnaHR0cHMnO1xuaW1wb3J0IHsgZ2V0SW5zdGFsbGF0aW9uVXVpZCB9IGZyb20gJy4vZ2V0X2luc3RhbGxhdGlvbl9pZC5qcyc7XG5pbXBvcnQgeyBsYXRlc3RQYXlsb2FkVmVyc2lvbiB9IGZyb20gJy4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGdldFVybCB9IGZyb20gJy4vZ2V0X3VzYWdlX2RhdGFfdXJsLmpzJztcbmltcG9ydCBpc0NJIGZyb20gJ2lzLWNpJztcbmltcG9ydCB7IFNlcmlhbGl6YWJsZUVycm9yIH0gZnJvbSAnLi9zZXJpYWxpemFibGVfZXJyb3IuanMnO1xuaW1wb3J0IHsgVXNhZ2VEYXRhRW1pdHRlciB9IGZyb20gJy4vdXNhZ2VfZGF0YV9lbWl0dGVyX2ZhY3RvcnkuanMnO1xuaW1wb3J0IHsgQW1wbGlmeUVycm9yIH0gZnJvbSAnLi4vaW5kZXguanMnO1xuXG4vKipcbiAqIEVudHJ5IHBvaW50IGZvciBzZW5kaW5nIHVzYWdlIGRhdGEgbWV0cmljc1xuICovXG5leHBvcnQgY2xhc3MgRGVmYXVsdFVzYWdlRGF0YUVtaXR0ZXIgaW1wbGVtZW50cyBVc2FnZURhdGFFbWl0dGVyIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yIGZvciBVc2FnZURhdGFFbWl0dGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGxpYnJhcnlWZXJzaW9uOiBzdHJpbmcsXG4gICAgcHJpdmF0ZSByZWFkb25seSBzZXNzaW9uVXVpZCA9IHV1aWQoKSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHVybCA9IGdldFVybCgpLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgYWNjb3VudElkRmV0Y2hlciA9IG5ldyBBY2NvdW50SWRGZXRjaGVyKClcbiAgKSB7fVxuXG4gIGVtaXRTdWNjZXNzID0gYXN5bmMgKFxuICAgIG1ldHJpY3M/OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+LFxuICAgIGRpbWVuc2lvbnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gICkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5nZXRVc2FnZURhdGEoe1xuICAgICAgICBzdGF0ZTogJ1NVQ0NFRURFRCcsXG4gICAgICAgIG1ldHJpY3MsXG4gICAgICAgIGRpbWVuc2lvbnMsXG4gICAgICB9KTtcbiAgICAgIGF3YWl0IHRoaXMuc2VuZChkYXRhKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhbXBsaWZ5LWJhY2tlbmQtcnVsZXMvbm8tZW1wdHktY2F0Y2hcbiAgICB9IGNhdGNoIHtcbiAgICAgIC8vIERvbid0IHByb3BhZ2F0ZSBlcnJvcnMgcmVsYXRlZCB0byBub3QgYmVpbmcgYWJsZSB0byBzZW5kIHRlbGVtZXRyeVxuICAgIH1cbiAgfTtcblxuICBlbWl0RmFpbHVyZSA9IGFzeW5jIChcbiAgICBlcnJvcjogQW1wbGlmeUVycm9yLFxuICAgIGRpbWVuc2lvbnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gICkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5nZXRVc2FnZURhdGEoe1xuICAgICAgICBzdGF0ZTogJ0ZBSUxFRCcsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBkaW1lbnNpb25zLFxuICAgICAgfSk7XG4gICAgICBhd2FpdCB0aGlzLnNlbmQoZGF0YSk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYW1wbGlmeS1iYWNrZW5kLXJ1bGVzL25vLWVtcHR5LWNhdGNoXG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBEb24ndCBwcm9wYWdhdGUgZXJyb3JzIHJlbGF0ZWQgdG8gbm90IGJlaW5nIGFibGUgdG8gc2VuZCB0ZWxlbWV0cnlcbiAgICB9XG4gIH07XG5cbiAgcHJpdmF0ZSBnZXRVc2FnZURhdGEgPSBhc3luYyAob3B0aW9uczoge1xuICAgIHN0YXRlOiAnU1VDQ0VFREVEJyB8ICdGQUlMRUQnO1xuICAgIG1ldHJpY3M/OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+O1xuICAgIGRpbWVuc2lvbnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICAgIGVycm9yPzogQW1wbGlmeUVycm9yO1xuICB9KTogUHJvbWlzZTxVc2FnZURhdGE+ID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgYWNjb3VudElkOiBhd2FpdCB0aGlzLmFjY291bnRJZEZldGNoZXIuZmV0Y2goKSxcbiAgICAgIHNlc3Npb25VdWlkOiB0aGlzLnNlc3Npb25VdWlkLFxuICAgICAgaW5zdGFsbGF0aW9uVXVpZDogZ2V0SW5zdGFsbGF0aW9uVXVpZCgpLFxuICAgICAgYW1wbGlmeUNsaVZlcnNpb246IHRoaXMubGlicmFyeVZlcnNpb24sXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIGVycm9yOiBvcHRpb25zLmVycm9yID8gbmV3IFNlcmlhbGl6YWJsZUVycm9yKG9wdGlvbnMuZXJyb3IpIDogdW5kZWZpbmVkLFxuICAgICAgZG93bnN0cmVhbUV4Y2VwdGlvbjpcbiAgICAgICAgb3B0aW9ucy5lcnJvciAmJlxuICAgICAgICBvcHRpb25zLmVycm9yLmNhdXNlICYmXG4gICAgICAgIG9wdGlvbnMuZXJyb3IuY2F1c2UgaW5zdGFuY2VvZiBFcnJvclxuICAgICAgICAgID8gbmV3IFNlcmlhbGl6YWJsZUVycm9yKG9wdGlvbnMuZXJyb3IuY2F1c2UpXG4gICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICBwYXlsb2FkVmVyc2lvbjogbGF0ZXN0UGF5bG9hZFZlcnNpb24sXG4gICAgICBvc1BsYXRmb3JtOiBvcy5wbGF0Zm9ybSgpLFxuICAgICAgb3NSZWxlYXNlOiBvcy5yZWxlYXNlKCksXG4gICAgICBub2RlVmVyc2lvbjogcHJvY2Vzcy52ZXJzaW9ucy5ub2RlLFxuICAgICAgc3RhdGU6IG9wdGlvbnMuc3RhdGUsXG4gICAgICBjb2RlUGF0aER1cmF0aW9uczogdGhpcy50cmFuc2xhdGVNZXRyaWNzVG9Vc2FnZURhdGEob3B0aW9ucy5tZXRyaWNzKSxcbiAgICAgIGlucHV0OiB0aGlzLnRyYW5zbGF0ZURpbWVuc2lvbnNUb1VzYWdlRGF0YShvcHRpb25zLmRpbWVuc2lvbnMpLFxuICAgICAgaXNDaTogaXNDSSxcbiAgICAgIHByb2plY3RTZXR0aW5nOiB7XG4gICAgICAgIGVkaXRvcjogcHJvY2Vzcy5lbnYubnBtX2NvbmZpZ191c2VyX2FnZW50LFxuICAgICAgfSxcbiAgICB9O1xuICB9O1xuXG4gIHByaXZhdGUgc2VuZCA9IChkYXRhOiBVc2FnZURhdGEpID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUpID0+IHtcbiAgICAgIGNvbnN0IHBheWxvYWQ6IHN0cmluZyA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgY29uc3QgcmVxID0gaHR0cHMucmVxdWVzdCh7XG4gICAgICAgIGhvc3RuYW1lOiB0aGlzLnVybC5ob3N0bmFtZSxcbiAgICAgICAgcG9ydDogdGhpcy51cmwucG9ydCxcbiAgICAgICAgcGF0aDogdGhpcy51cmwucGF0aCxcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdjb250ZW50LWxlbmd0aCc6IHBheWxvYWQubGVuZ3RoLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgICByZXEub24oJ2Vycm9yJywgKCkgPT4ge1xuICAgICAgICAvKiBub29wICovXG4gICAgICB9KTtcbiAgICAgIHJlcS5zZXRUaW1lb3V0KDIwMDAsICgpID0+IHtcbiAgICAgICAgLy8gMiBzZWNvbmRzXG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXEud3JpdGUocGF5bG9hZCk7XG4gICAgICByZXEuZW5kKCgpID0+IHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgcHJpdmF0ZSB0cmFuc2xhdGVNZXRyaWNzVG9Vc2FnZURhdGEgPSAobWV0cmljcz86IFJlY29yZDxzdHJpbmcsIG51bWJlcj4pID0+IHtcbiAgICBpZiAoIW1ldHJpY3MpIHJldHVybiB7fTtcbiAgICBsZXQgdG90YWxEdXJhdGlvbiwgcGxhdGZvcm1TdGFydHVwO1xuICAgIGZvciAoY29uc3QgW25hbWUsIGRhdGFdIG9mIE9iamVjdC5lbnRyaWVzKG1ldHJpY3MpKSB7XG4gICAgICBpZiAobmFtZSA9PT0gJ3RvdGFsVGltZScpIHtcbiAgICAgICAgdG90YWxEdXJhdGlvbiA9IE1hdGgucm91bmQoZGF0YSk7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdzeW50aGVzaXNUaW1lJykge1xuICAgICAgICBwbGF0Zm9ybVN0YXJ0dXAgPSBNYXRoLnJvdW5kKGRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyB0b3RhbER1cmF0aW9uLCBwbGF0Zm9ybVN0YXJ0dXAgfTtcbiAgfTtcblxuICBwcml2YXRlIHRyYW5zbGF0ZURpbWVuc2lvbnNUb1VzYWdlRGF0YSA9IChcbiAgICBkaW1lbnNpb25zPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICApID0+IHtcbiAgICBsZXQgY29tbWFuZCA9ICcnO1xuICAgIGlmIChkaW1lbnNpb25zKSB7XG4gICAgICBmb3IgKGNvbnN0IFtuYW1lLCBkYXRhXSBvZiBPYmplY3QuZW50cmllcyhkaW1lbnNpb25zKSkge1xuICAgICAgICBpZiAobmFtZSA9PT0gJ2NvbW1hbmQnKSB7XG4gICAgICAgICAgY29tbWFuZCA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgY29tbWFuZCwgcGx1Z2luOiAnR2VuMicgfTtcbiAgfTtcbn1cbiJdfQ==